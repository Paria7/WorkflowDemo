/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.18.0 (NJsonSchema v9.13.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AdministrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * get all users
     * @return Success
     */
    getUsers(): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }

    /**
     * search users
     * @param filter (optional) search filter
     * @return Success
     */
    searchUsers(filter: string | null | undefined): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/SearchUsers?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchUsers(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }

    /**
     * save user
     * @param entity (optional) user
     * @return Success
     */
    saveUser(entity: UserEntity | null | undefined): Observable<UserEntity> {
        let url_ = this.baseUrl + "/api/Administration/SaveUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUser(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUser(response: HttpResponseBase): Observable<UserEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserEntity.fromJS(resultData200) : new UserEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity>(<any>null);
    }

    /**
     * get login user
     * @return Success
     */
    getLoginUserInfo(): Observable<UserEntity> {
        let url_ = this.baseUrl + "/api/Administration/GetLoginUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoginUserInfo(response: HttpResponseBase): Observable<UserEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserEntity.fromJS(resultData200) : new UserEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity>(<any>null);
    }

    /**
     * remove user
     * @param id user id
     * @return Success
     */
    removeUser(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Administration/RemoveUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get all roles
     * @return Success
     */
    getRoles(): Observable<RoleEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleEntity[]>(<any>null);
    }

    /**
     * search roles
     * @param filter (optional) search filter
     * @return Success
     */
    searchRoles(filter: string | null | undefined): Observable<RoleEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/SearchRoles?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchRoles(response: HttpResponseBase): Observable<RoleEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleEntity[]>(<any>null);
    }

    /**
     * save role
     * @param entity (optional) role
     * @return Success
     */
    saveRole(entity: RoleEntity | null | undefined): Observable<RoleEntity> {
        let url_ = this.baseUrl + "/api/Administration/SaveRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleEntity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveRole(response: HttpResponseBase): Observable<RoleEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleEntity.fromJS(resultData200) : new RoleEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleEntity>(<any>null);
    }

    /**
     * remove role
     * @param id role id
     * @return Success
     */
    removeRole(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Administration/RemoveRole/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get all function groups
     * @return Success
     */
    getFunctionGroups(): Observable<FunctionGroupEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/GetFunctionGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFunctionGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFunctionGroups(<any>response_);
                } catch (e) {
                    return <Observable<FunctionGroupEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FunctionGroupEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFunctionGroups(response: HttpResponseBase): Observable<FunctionGroupEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FunctionGroupEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FunctionGroupEntity[]>(<any>null);
    }

    /**
     * get function groups by role
     * @param role (optional) role
     * @return Success
     */
    getFunctionGroupsByRole(role: RoleEntity | null | undefined): Observable<FunctionGroupEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/GetFunctionGroupsByRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFunctionGroupsByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFunctionGroupsByRole(<any>response_);
                } catch (e) {
                    return <Observable<FunctionGroupEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FunctionGroupEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFunctionGroupsByRole(response: HttpResponseBase): Observable<FunctionGroupEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FunctionGroupEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FunctionGroupEntity[]>(<any>null);
    }

    /**
     * save functions
     * @param functionGroupEntities (optional) functions
     * @return Success
     */
    saveRoleFunctions(functionGroupEntities: FunctionGroupEntity[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Administration/SaveRoleFunctions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(functionGroupEntities);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRoleFunctions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRoleFunctions(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSaveRoleFunctions(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * get user info by user name or email address
     * @param userInfo (optional) user name or email address
     * @return Success
     */
    getUserAdAccount(userInfo: string | null | undefined): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/GetUserAdAccount?";
        if (userInfo !== undefined)
            url_ += "userInfo=" + encodeURIComponent("" + userInfo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAdAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAdAccount(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAdAccount(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }

    /**
     * get user statuses
     * @return Success
     */
    getUserStatuses(): Observable<StatusEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/GetUserStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserStatuses(<any>response_);
                } catch (e) {
                    return <Observable<StatusEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserStatuses(response: HttpResponseBase): Observable<StatusEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusEntity[]>(<any>null);
    }

    /**
     * search users
     * @param userName (optional) 
     * @param employeeNo (optional) 
     * @param role (optional) 
     * @param status (optional) 
     * @param name (optional) 
     * @param plantId (optional) 
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    queryUsers(userName: string | null | undefined, employeeNo: string | null | undefined, role: string | null | undefined, status: number | null | undefined, name: string | null | undefined, plantId: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/Administration/QueryUsers?";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (employeeNo !== undefined)
            url_ += "EmployeeNo=" + encodeURIComponent("" + employeeNo) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryUsers(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }
}

@Injectable()
export class AreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAreas(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/Area/GetAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param name (optional) 车间名称
     * @param code (optional) 车间代码
     * @param status (optional) 状态
     * @param plantId (optional) 所属工厂Id
     * @return Success
     */
    queryAreas(name: string | null | undefined, code: string | null | undefined, status: number | null | undefined, plantId: string | null | undefined): Observable<AreaOutput[]> {
        let url_ = this.baseUrl + "/api/Area/QueryAreas?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryAreas(<any>response_);
                } catch (e) {
                    return <Observable<AreaOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryAreas(response: HttpResponseBase): Observable<AreaOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AreaOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaOutput[]>(<any>null);
    }

    /**
     * get all area statuses
     * @return Success
     */
    getAreaStatuses(): Observable<StatusEntity[]> {
        let url_ = this.baseUrl + "/api/Area/GetAreaStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaStatuses(<any>response_);
                } catch (e) {
                    return <Observable<StatusEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreaStatuses(response: HttpResponseBase): Observable<StatusEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusEntity[]>(<any>null);
    }

    /**
     * save area
     * @param entity (optional) area
     * @return Success
     */
    saveArea(entity: AreaOutput | null | undefined): Observable<AreaOutput> {
        let url_ = this.baseUrl + "/api/Area/SaveArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveArea(<any>response_);
                } catch (e) {
                    return <Observable<AreaOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSaveArea(response: HttpResponseBase): Observable<AreaOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AreaOutput.fromJS(resultData200) : new AreaOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaOutput>(<any>null);
    }

    /**
     * remove area
     * @param id area id
     * @return Success
     */
    removeArea(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Area/RemoveArea/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveArea(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveArea(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get owner list by area id
     * @param areaId (optional) 
     * @return Success
     */
    getOwnerListByAreaId(areaId: string | null | undefined): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/Area/GetOwnerListByAreaId?";
        if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerListByAreaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerListByAreaId(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnerListByAreaId(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }

    /**
     * save owner list
     * @param entity (optional) entity
     * @return Success
     */
    saveOwnerList(entity: AreaUserDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Area/SaveOwnerList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOwnerList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOwnerList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveOwnerList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get string format of map by id
     * @param mapId (optional) 
     * @return Success
     */
    getMapStrById(mapId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Area/GetMapStrById?";
        if (mapId !== undefined)
            url_ += "mapId=" + encodeURIComponent("" + mapId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMapStrById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMapStrById(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMapStrById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 上传附件
     * @param areaId (optional) areaId
     * @param file (optional) 这个参数名称必须跟前端 type="file" 控件的name值相同
     * @param id (optional) ID
     * @param name (optional) name
     * @return Success
     */
    uploadFile(areaId: string | null | undefined, file: FileParameter | null | undefined, id: string | null | undefined, name: string | null | undefined): Observable<FileUploadOutput> {
        let url_ = this.baseUrl + "/api/Area/UploadFile?";
        if (areaId !== undefined)
            url_ += "areaId=" + encodeURIComponent("" + areaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileUploadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileUploadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<FileUploadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileUploadOutput.fromJS(resultData200) : new FileUploadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileUploadOutput>(<any>null);
    }
}

@Injectable()
export class AttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadFile(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachment/DownloadFile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param fileInfo (optional) 
     * @return Success
     */
    uploadFile(fileInfo: FileInfoDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Attachment/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fileInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 上传附件
     * @param file (optional) 这个参数名称必须跟前端 type="file" 控件的name值相同
     * @param id (optional) ID
     * @param name (optional) name
     * @return Success
     */
    uploadFileDemo(file: FileParameter | null | undefined, id: string | null | undefined, name: string | null | undefined): Observable<FileUploadOutput> {
        let url_ = this.baseUrl + "/api/Attachment/UploadFileDemo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFileDemo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFileDemo(<any>response_);
                } catch (e) {
                    return <Observable<FileUploadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileUploadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFileDemo(response: HttpResponseBase): Observable<FileUploadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileUploadOutput.fromJS(resultData200) : new FileUploadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileUploadOutput>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 查询AuditLog
     * @param logType (optional) 日志类型 0:不区分，查询所有 1:审计日志 2:异常日志 3:业务日志
     * @param startTime (optional) 开始时间
     * @param endTime (optional) 截止时间
     * @param userName (optional) 用户名
     * @param userNo (optional) 工号
     * @param serviceName (optional) 服务名
     * @param actionName (optional) Action名
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    getAuditLogData(logType: number | null | undefined, startTime: Date | null | undefined, endTime: Date | null | undefined, userName: string | null | undefined, userNo: string | null | undefined, serviceName: string | null | undefined, actionName: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<AuditLogOutput> {
        let url_ = this.baseUrl + "/api/AuditLog/GetAuditLogData?";
        if (logType !== undefined)
            url_ += "LogType=" + encodeURIComponent("" + logType) + "&"; 
        if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (userNo !== undefined)
            url_ += "UserNo=" + encodeURIComponent("" + userNo) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (actionName !== undefined)
            url_ += "ActionName=" + encodeURIComponent("" + actionName) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogData(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogData(response: HttpResponseBase): Observable<AuditLogOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditLogOutput.fromJS(resultData200) : new AuditLogOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogOutput>(<any>null);
    }

    /**
     * 查询AuditLog明细信息
     * @param id (optional) 主键
     * @return Success
     */
    getDetailAuditLog(id: string | null | undefined): Observable<AuditLogOutputModel> {
        let url_ = this.baseUrl + "/api/AuditLog/GetDetailAuditLog?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailAuditLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailAuditLog(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogOutputModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogOutputModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailAuditLog(response: HttpResponseBase): Observable<AuditLogOutputModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditLogOutputModel.fromJS(resultData200) : new AuditLogOutputModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogOutputModel>(<any>null);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * do login
     * @param entity (optional) LoginEntity
     * @return Success
     */
    loginOld(entity: LoginEntity | null | undefined): Observable<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/Auth/LoginOld";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginOld(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginOld(<any>response_);
                } catch (e) {
                    return <Observable<LoginResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processLoginOld(response: HttpResponseBase): Observable<LoginResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginResponseModel.fromJS(resultData200) : new LoginResponseModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseModel>(<any>null);
    }

    /**
     * LoginByAd
     * @param entity (optional) 
     * @return Success
     */
    login(entity: LoginEntity | null | undefined): Observable<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/Auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<LoginResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginResponseModel.fromJS(resultData200) : new LoginResponseModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseModel>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * get device uers by device id
     * @param id (optional) device id
     * @return Success
     */
    getDeviceUsers(id: string | null | undefined): Observable<DeviceUsersOutPut> {
        let url_ = this.baseUrl + "/api/Device/GetDeviceUsers?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceUsers(<any>response_);
                } catch (e) {
                    return <Observable<DeviceUsersOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceUsersOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceUsers(response: HttpResponseBase): Observable<DeviceUsersOutPut> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeviceUsersOutPut.fromJS(resultData200) : new DeviceUsersOutPut();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceUsersOutPut>(<any>null);
    }

    /**
     * get device by line
     * @param id (optional) line id
     * @return Success
     */
    getDevicesByLine(id: string | null | undefined): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/Device/GetDevicesByLine?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesByLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesByLine(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevicesByLine(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * query device
     * @param name (optional) 产线名称
     * @param code (optional) 产线代码
     * @param status (optional) 状态
     * @param plantId (optional) 所属工厂Id
     * @param lineId (optional) 所属产线Id
     * @param areaId (optional) 所属车间Id
     * @param stationId (optional) 所属工作站Id
     * @param valueStreamId (optional) 所属价值流Id
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    queryDevices(name: string | null | undefined, code: string | null | undefined, status: number | null | undefined, plantId: string | null | undefined, lineId: string | null | undefined, areaId: string | null | undefined, stationId: string | null | undefined, valueStreamId: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<DeviceDetailOutput> {
        let url_ = this.baseUrl + "/api/Device/QueryDevices?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (stationId !== undefined)
            url_ += "StationId=" + encodeURIComponent("" + stationId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryDevices(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processQueryDevices(response: HttpResponseBase): Observable<DeviceDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeviceDetailOutput.fromJS(resultData200) : new DeviceDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDetailOutput>(<any>null);
    }

    /**
     * save device
     * @param input (optional) DeviceDetailDto
     * @return Success
     */
    saveDevice(input: DeviceDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Device/SaveDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * remove device
     * @param id device id
     * @return Success
     */
    removeDevice(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Device/RemoveDevice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get all device statuses
     * @return Success
     */
    getDeviceStatuses(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/Device/GetDeviceStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceStatuses(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceStatuses(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }
}

@Injectable()
export class LineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * WebUI: get all lines
     * @return Success
     */
    getLines(): Observable<LineEntity[]> {
        let url_ = this.baseUrl + "/api/Line/GetLines";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLines(<any>response_);
                } catch (e) {
                    return <Observable<LineEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLines(response: HttpResponseBase): Observable<LineEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LineEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineEntity[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLinesByArea(id: string | null | undefined): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/Line/GetLinesByArea?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinesByArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinesByArea(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinesByArea(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * WebUI: query plants
     * @param id (optional) 
     * @param createdOn (optional) 
     * @param createdBy (optional) 
     * @param updatedOn (optional) 
     * @param updatedBy (optional) 
     * @param plantId (optional) 
     * @param code (optional) 
     * @param name (optional) 
     * @param isActive (optional) 
     * @param isNewLine (optional) 
     * @param description (optional) 
     * @param plantCode (optional) 
     * @param plantName (optional) 
     * @param processId (optional) 
     * @param processName (optional) 
     * @param isDeleted (optional) 
     * @return Success
     */
    queryLines(id: string | null | undefined, createdOn: Date | null | undefined, createdBy: string | null | undefined, updatedOn: Date | null | undefined, updatedBy: string | null | undefined, plantId: string | null | undefined, code: string | null | undefined, name: string | null | undefined, isActive: boolean | null | undefined, isNewLine: boolean | null | undefined, description: string | null | undefined, plantCode: string | null | undefined, plantName: string | null | undefined, processId: string | null | undefined, processName: string | null | undefined, isDeleted: boolean | null | undefined): Observable<LineEntity[]> {
        let url_ = this.baseUrl + "/api/Line/QueryLines?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (createdOn !== undefined)
            url_ += "CreatedOn=" + encodeURIComponent(createdOn ? "" + createdOn.toJSON() : "") + "&"; 
        if (createdBy !== undefined)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&"; 
        if (updatedOn !== undefined)
            url_ += "UpdatedOn=" + encodeURIComponent(updatedOn ? "" + updatedOn.toJSON() : "") + "&"; 
        if (updatedBy !== undefined)
            url_ += "UpdatedBy=" + encodeURIComponent("" + updatedBy) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (isNewLine !== undefined)
            url_ += "IsNewLine=" + encodeURIComponent("" + isNewLine) + "&"; 
        if (description !== undefined)
            url_ += "Description=" + encodeURIComponent("" + description) + "&"; 
        if (plantCode !== undefined)
            url_ += "PlantCode=" + encodeURIComponent("" + plantCode) + "&"; 
        if (plantName !== undefined)
            url_ += "PlantName=" + encodeURIComponent("" + plantName) + "&"; 
        if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&"; 
        if (processName !== undefined)
            url_ += "ProcessName=" + encodeURIComponent("" + processName) + "&"; 
        if (isDeleted !== undefined)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryLines(<any>response_);
                } catch (e) {
                    return <Observable<LineEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryLines(response: HttpResponseBase): Observable<LineEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LineEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineEntity[]>(<any>null);
    }

    /**
     * save line
     * @param entity (optional) line
     * @return Success
     */
    saveLine(entity: LineEntity | null | undefined): Observable<LineEntity> {
        let url_ = this.baseUrl + "/api/Line/SaveLine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLine(<any>response_);
                } catch (e) {
                    return <Observable<LineEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineEntity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLine(response: HttpResponseBase): Observable<LineEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LineEntity.fromJS(resultData200) : new LineEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineEntity>(<any>null);
    }

    /**
     * remove line
     * @param id line id
     * @return Success
     */
    removeLine(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Line/RemoveLine/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveLine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get standard kpi template
     * @param id (optional) 
     * @param createdOn (optional) 
     * @param createdBy (optional) 
     * @param updatedOn (optional) 
     * @param updatedBy (optional) 
     * @param plantId (optional) 
     * @param code (optional) 
     * @param name (optional) 
     * @param isActive (optional) 
     * @param isNewLine (optional) 
     * @param description (optional) 
     * @param plantCode (optional) 
     * @param plantName (optional) 
     * @param processId (optional) 
     * @param processName (optional) 
     * @param isDeleted (optional) 
     * @return Success
     */
    downloadStandardTemplate(id: string | null | undefined, createdOn: Date | null | undefined, createdBy: string | null | undefined, updatedOn: Date | null | undefined, updatedBy: string | null | undefined, plantId: string | null | undefined, code: string | null | undefined, name: string | null | undefined, isActive: boolean | null | undefined, isNewLine: boolean | null | undefined, description: string | null | undefined, plantCode: string | null | undefined, plantName: string | null | undefined, processId: string | null | undefined, processName: string | null | undefined, isDeleted: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Line/DownloadStandardTemplate?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (createdOn !== undefined)
            url_ += "CreatedOn=" + encodeURIComponent(createdOn ? "" + createdOn.toJSON() : "") + "&"; 
        if (createdBy !== undefined)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&"; 
        if (updatedOn !== undefined)
            url_ += "UpdatedOn=" + encodeURIComponent(updatedOn ? "" + updatedOn.toJSON() : "") + "&"; 
        if (updatedBy !== undefined)
            url_ += "UpdatedBy=" + encodeURIComponent("" + updatedBy) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (isNewLine !== undefined)
            url_ += "IsNewLine=" + encodeURIComponent("" + isNewLine) + "&"; 
        if (description !== undefined)
            url_ += "Description=" + encodeURIComponent("" + description) + "&"; 
        if (plantCode !== undefined)
            url_ += "PlantCode=" + encodeURIComponent("" + plantCode) + "&"; 
        if (plantName !== undefined)
            url_ += "PlantName=" + encodeURIComponent("" + plantName) + "&"; 
        if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&"; 
        if (processName !== undefined)
            url_ += "ProcessName=" + encodeURIComponent("" + processName) + "&"; 
        if (isDeleted !== undefined)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadStandardTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadStandardTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadStandardTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LineDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param name (optional) 产线名称
     * @param code (optional) 产线代码
     * @param status (optional) 状态
     * @param plantId (optional) 所属工厂Id
     * @param areaId (optional) 所属车间Id
     * @param valueStreamId (optional) 所属价值流Id
     * @return Success
     */
    queryLines(id: string | null | undefined, name: string | null | undefined, code: string | null | undefined, status: number | null | undefined, plantId: string | null | undefined, areaId: string | null | undefined, valueStreamId: string | null | undefined): Observable<LineDetailOutput[]> {
        let url_ = this.baseUrl + "/api/LineDetail/QueryLines?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryLines(<any>response_);
                } catch (e) {
                    return <Observable<LineDetailOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineDetailOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryLines(response: HttpResponseBase): Observable<LineDetailOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LineDetailOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineDetailOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 产线名称
     * @param code (optional) 产线代码
     * @param status (optional) 状态
     * @param plantId (optional) 所属工厂Id
     * @param areaId (optional) 所属车间Id
     * @param valueStreamId (optional) 所属价值流Id
     * @return Success
     */
    queryLinesFromPortal(id: string | null | undefined, name: string | null | undefined, code: string | null | undefined, status: number | null | undefined, plantId: string | null | undefined, areaId: string | null | undefined, valueStreamId: string | null | undefined): Observable<LineDetailOutput[]> {
        let url_ = this.baseUrl + "/api/LineDetail/QueryLinesFromPortal?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryLinesFromPortal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryLinesFromPortal(<any>response_);
                } catch (e) {
                    return <Observable<LineDetailOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineDetailOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryLinesFromPortal(response: HttpResponseBase): Observable<LineDetailOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LineDetailOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineDetailOutput[]>(<any>null);
    }

    /**
     * save line
     * @param entity (optional) line
     * @return Success
     */
    saveLine(entity: LineDetailOutput | null | undefined): Observable<LineDetailOutput> {
        let url_ = this.baseUrl + "/api/LineDetail/SaveLine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLine(<any>response_);
                } catch (e) {
                    return <Observable<LineDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLine(response: HttpResponseBase): Observable<LineDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LineDetailOutput.fromJS(resultData200) : new LineDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineDetailOutput>(<any>null);
    }

    /**
     * remove line
     * @param id area line
     * @return Success
     */
    removeLine(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/LineDetail/RemoveLine/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveLine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get all line statuses
     * @return Success
     */
    getLineStatuses(): Observable<StatusEntity[]> {
        let url_ = this.baseUrl + "/api/LineDetail/GetLineStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineStatuses(<any>response_);
                } catch (e) {
                    return <Observable<StatusEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLineStatuses(response: HttpResponseBase): Observable<StatusEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusEntity[]>(<any>null);
    }

    /**
     * get owner list by line id
     * @param lineId (optional) 
     * @return Success
     */
    getOwnerListByLineId(lineId: string | null | undefined): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/LineDetail/GetOwnerListByLineId?";
        if (lineId !== undefined)
            url_ += "lineId=" + encodeURIComponent("" + lineId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerListByLineId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerListByLineId(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnerListByLineId(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }

    /**
     * get member list by line id
     * @param lineId (optional) 
     * @return Success
     */
    getMemberListByLineId(lineId: string | null | undefined): Observable<UserEntity[]> {
        let url_ = this.baseUrl + "/api/LineDetail/GetMemberListByLineId?";
        if (lineId !== undefined)
            url_ += "lineId=" + encodeURIComponent("" + lineId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberListByLineId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberListByLineId(<any>response_);
                } catch (e) {
                    return <Observable<UserEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberListByLineId(response: HttpResponseBase): Observable<UserEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEntity[]>(<any>null);
    }

    /**
     * save user list
     * @param entity (optional) entity
     * @return Success
     */
    saveUserList(entity: LineUserDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/LineDetail/SaveUserList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get string format of map by id
     * @param mapId (optional) 
     * @return Success
     */
    getMapStrById(mapId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/LineDetail/GetMapStrById?";
        if (mapId !== undefined)
            url_ += "mapId=" + encodeURIComponent("" + mapId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMapStrById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMapStrById(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMapStrById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 上传附件
     * @param lineId (optional) lineId
     * @param file (optional) 这个参数名称必须跟前端 type="file" 控件的name值相同
     * @param id (optional) ID
     * @param name (optional) name
     * @return Success
     */
    uploadFile(lineId: string | null | undefined, file: FileParameter | null | undefined, id: string | null | undefined, name: string | null | undefined): Observable<FileUploadOutput> {
        let url_ = this.baseUrl + "/api/LineDetail/UploadFile?";
        if (lineId !== undefined)
            url_ += "lineId=" + encodeURIComponent("" + lineId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileUploadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileUploadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<FileUploadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileUploadOutput.fromJS(resultData200) : new FileUploadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileUploadOutput>(<any>null);
    }
}

@Injectable()
export class LineEditServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 查询device，包括station信息
     * @param lineId (optional) 
     * @param lineShowName (optional) portal上面显示的line 名称，需要截取Line1
     * @return Success
     */
    getDevicesAndStationsByLine(lineId: string | null | undefined, lineShowName: string | null | undefined): Observable<DeviceAndStationOutput[]> {
        let url_ = this.baseUrl + "/api/LineEdit/GetDevicesAndStationsByLine?";
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (lineShowName !== undefined)
            url_ += "LineShowName=" + encodeURIComponent("" + lineShowName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesAndStationsByLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesAndStationsByLine(<any>response_);
                } catch (e) {
                    return <Observable<DeviceAndStationOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceAndStationOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevicesAndStationsByLine(response: HttpResponseBase): Observable<DeviceAndStationOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceAndStationOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceAndStationOutput[]>(<any>null);
    }

    /**
     * 新增或更新 line-edit
     * @param detail (optional) 详情信息
     * @return Success
     */
    addOrUpdateLineEdit(detail: DeviceAndStationOutput | null | undefined): Observable<ResponseBase> {
        let url_ = this.baseUrl + "/api/LineEdit/AddOrUpdateLineEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(detail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateLineEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateLineEdit(<any>response_);
                } catch (e) {
                    return <Observable<ResponseBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseBase>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateLineEdit(response: HttpResponseBase): Observable<ResponseBase> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseBase.fromJS(resultData200) : new ResponseBase();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseBase>(<any>null);
    }

    /**
     * 删除line-edit上面的device
     * @param id id
     * @return Success
     */
    deleteLineEdit(id: string): Observable<ResponseBase> {
        let url_ = this.baseUrl + "/api/LineEdit/DeleteLineEdit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLineEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLineEdit(<any>response_);
                } catch (e) {
                    return <Observable<ResponseBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseBase>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLineEdit(response: HttpResponseBase): Observable<ResponseBase> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseBase.fromJS(resultData200) : new ResponseBase();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseBase>(<any>null);
    }

    /**
     * 获取Line的Map备件图片
     * @param lineId (optional) 
     * @param lineShowName (optional) portal上面显示的line 名称，需要截取Line1
     * @return Success
     */
    getLineMapImgUrl(lineId: string | null | undefined, lineShowName: string | null | undefined): Observable<LineMapImgOutput> {
        let url_ = this.baseUrl + "/api/LineEdit/GetLineMapImgUrl?";
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (lineShowName !== undefined)
            url_ += "LineShowName=" + encodeURIComponent("" + lineShowName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLineMapImgUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLineMapImgUrl(<any>response_);
                } catch (e) {
                    return <Observable<LineMapImgOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineMapImgOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLineMapImgUrl(response: HttpResponseBase): Observable<LineMapImgOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LineMapImgOutput.fromJS(resultData200) : new LineMapImgOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineMapImgOutput>(<any>null);
    }

    /**
     * 查看检查项目是否已经全部完成
     * @param deviceId (optional) deviceId
     * @return Success
     */
    getCheckDetailsIsAllComplete(deviceId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LineEdit/GetCheckDetailsIsAllComplete?";
        if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckDetailsIsAllComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckDetailsIsAllComplete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckDetailsIsAllComplete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 接入api getway 暴露的接口
     * @return Success
     */
    meta(): Observable<void> {
        let url_ = this.baseUrl + "/api/Meta";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMeta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMeta(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMeta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OplServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOplStatuses(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/Opl/GetOplStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOplStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOplStatuses(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOplStatuses(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param area (optional) 
     * @param valueStream (optional) 
     * @param line (optional) 
     * @param device (optional) 
     * @param status (optional) 
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    queryOpls(area: string | null | undefined, valueStream: string | null | undefined, line: string | null | undefined, device: string | null | undefined, status: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<OplCenterDtoOutPut> {
        let url_ = this.baseUrl + "/api/Opl/QueryOpls?";
        if (area !== undefined)
            url_ += "Area=" + encodeURIComponent("" + area) + "&"; 
        if (valueStream !== undefined)
            url_ += "ValueStream=" + encodeURIComponent("" + valueStream) + "&"; 
        if (line !== undefined)
            url_ += "Line=" + encodeURIComponent("" + line) + "&"; 
        if (device !== undefined)
            url_ += "Device=" + encodeURIComponent("" + device) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryOpls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryOpls(<any>response_);
                } catch (e) {
                    return <Observable<OplCenterDtoOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<OplCenterDtoOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processQueryOpls(response: HttpResponseBase): Observable<OplCenterDtoOutPut> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OplCenterDtoOutPut.fromJS(resultData200) : new OplCenterDtoOutPut();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OplCenterDtoOutPut>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    queryTabOpls(type: number | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<OplCenterDtoOutPut> {
        let url_ = this.baseUrl + "/api/Opl/QueryTabOpls?";
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryTabOpls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryTabOpls(<any>response_);
                } catch (e) {
                    return <Observable<OplCenterDtoOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<OplCenterDtoOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processQueryTabOpls(response: HttpResponseBase): Observable<OplCenterDtoOutPut> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OplCenterDtoOutPut.fromJS(resultData200) : new OplCenterDtoOutPut();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OplCenterDtoOutPut>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    assignOpl(input: AssignOplDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Opl/AssignOpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignOpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignOpl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignOpl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param entity (optional) 
     * @return Success
     */
    saveOpl(entity: OplDto | null | undefined): Observable<OplDto> {
        let url_ = this.baseUrl + "/api/Opl/SaveOpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOpl(<any>response_);
                } catch (e) {
                    return <Observable<OplDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OplDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveOpl(response: HttpResponseBase): Observable<OplDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OplDto.fromJS(resultData200) : new OplDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OplDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveOplDetail(input: OplDetailSaveDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Opl/SaveOplDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOplDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOplDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveOplDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    completeOplDetail(input: OplDetailCompleteDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Opl/CompleteOplDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteOplDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteOplDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteOplDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteOrCancelOpl(input: DeleteOrCancelOplDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Opl/DeleteOrCancelOpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrCancelOpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrCancelOpl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrCancelOpl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteOplDetail(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Opl/DeleteOplDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOplDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOplDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOplDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param area (optional) 
     * @param valueStream (optional) 
     * @param line (optional) 
     * @param device (optional) 
     * @param status (optional) 
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    downLoadOplDetail(area: string | null | undefined, valueStream: string | null | undefined, line: string | null | undefined, device: string | null | undefined, status: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Opl/DownLoadOplDetail?";
        if (area !== undefined)
            url_ += "Area=" + encodeURIComponent("" + area) + "&"; 
        if (valueStream !== undefined)
            url_ += "ValueStream=" + encodeURIComponent("" + valueStream) + "&"; 
        if (line !== undefined)
            url_ += "Line=" + encodeURIComponent("" + line) + "&"; 
        if (device !== undefined)
            url_ += "Device=" + encodeURIComponent("" + device) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownLoadOplDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownLoadOplDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownLoadOplDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PlantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * WebUI: get all plants
     * @return Success
     */
    getPlants(): Observable<PlantEntity[]> {
        let url_ = this.baseUrl + "/api/Plant/GetPlants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlants(<any>response_);
                } catch (e) {
                    return <Observable<PlantEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlants(response: HttpResponseBase): Observable<PlantEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlantEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantEntity[]>(<any>null);
    }

    /**
     * WebUI: get plants by conditions
     * @param code (optional) 
     * @param name (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    queryPlants(code: string | null | undefined, name: string | null | undefined, isActive: boolean | null | undefined): Observable<PlantEntity[]> {
        let url_ = this.baseUrl + "/api/Plant/QueryPlants?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryPlants(<any>response_);
                } catch (e) {
                    return <Observable<PlantEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryPlants(response: HttpResponseBase): Observable<PlantEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlantEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantEntity[]>(<any>null);
    }

    /**
     * save plant
     * @param entity (optional) plant
     * @return Success
     */
    savePlant(entity: PlantEntity | null | undefined): Observable<PlantEntity> {
        let url_ = this.baseUrl + "/api/Plant/SavePlant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePlant(<any>response_);
                } catch (e) {
                    return <Observable<PlantEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlantEntity>><any>_observableThrow(response_);
        }));
    }

    protected processSavePlant(response: HttpResponseBase): Observable<PlantEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PlantEntity.fromJS(resultData200) : new PlantEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlantEntity>(<any>null);
    }

    /**
     * remove plant
     * @param id plant id
     * @return Success
     */
    removePlant(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Plant/RemovePlant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePlant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemovePlant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * register user
     * @param entity (optional) register entity
     * @return Success
     */
    registerUser(entity: RegistrationEntity | null | undefined): Observable<RegistrationEntity> {
        let url_ = this.baseUrl + "/api/Registration/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<RegistrationEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegistrationEntity>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<RegistrationEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegistrationEntity.fromJS(resultData200) : new RegistrationEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationEntity>(<any>null);
    }

    /**
     * change user password
     * @param entity (optional) change password entity
     * @return Success
     */
    changePassword(entity: ChangePasswordEntity | null | undefined): Observable<ChangePasswordEntity> {
        let url_ = this.baseUrl + "/api/Registration/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordEntity>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ChangePasswordEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChangePasswordEntity.fromJS(resultData200) : new ChangePasswordEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordEntity>(<any>null);
    }
}

@Injectable()
export class StationDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * query station
     * @param name (optional) 产线名称
     * @param code (optional) 产线代码
     * @param status (optional) 状态
     * @param plantId (optional) 所属工厂Id
     * @param lineId (optional) 所属产线Id
     * @param areaId (optional) 所属车间Id
     * @param valueStreamId (optional) 所属价值流Id
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    queryStations(name: string | null | undefined, code: string | null | undefined, status: number | null | undefined, plantId: string | null | undefined, lineId: string | null | undefined, areaId: string | null | undefined, valueStreamId: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<StationDetailOutput> {
        let url_ = this.baseUrl + "/api/StationDetail/QueryStations?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryStations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryStations(<any>response_);
                } catch (e) {
                    return <Observable<StationDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StationDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processQueryStations(response: HttpResponseBase): Observable<StationDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StationDetailOutput.fromJS(resultData200) : new StationDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StationDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStationsByLine(id: string | null | undefined): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/StationDetail/GetStationsByLine?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStationsByLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStationsByLine(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStationsByLine(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * save station
     * @param input (optional) stationDetailDto
     * @return Success
     */
    saveStation(input: StationDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/StationDetail/SaveStation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveStation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * remove station
     * @param id station id
     * @return Success
     */
    removeStation(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/StationDetail/RemoveStation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveStation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveStation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveStation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get all station statuses
     * @return Success
     */
    getStationStatuses(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/StationDetail/GetStationStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStationStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStationStatuses(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStationStatuses(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }
}

@Injectable()
export class SystemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * WebUI: get all menus
     * @return Success
     */
    getMenus(): Observable<MenuEntity[]> {
        let url_ = this.baseUrl + "/api/System/GetMenus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenus(<any>response_);
                } catch (e) {
                    return <Observable<MenuEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenus(response: HttpResponseBase): Observable<MenuEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuEntity[]>(<any>null);
    }

    /**
     * WebUI: get all user menus
     * @return Success
     */
    getUserMenus(): Observable<MenuEntity[]> {
        let url_ = this.baseUrl + "/api/System/GetUserMenus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserMenus(<any>response_);
                } catch (e) {
                    return <Observable<MenuEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserMenus(response: HttpResponseBase): Observable<MenuEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuEntity[]>(<any>null);
    }
}

@Injectable()
export class TestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get array
     * @param i (optional) 
     * @return Success
     */
    testGet(i: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Test/TestGet?";
        if (i !== undefined)
            url_ += "i=" + encodeURIComponent("" + i) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGet(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestGet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class TpmServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 查询所有车间信息
     * @return Success
     */
    getAreas(): Observable<AreaOutput[]> {
        let url_ = this.baseUrl + "/api/Tpm/GetAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<AreaOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<AreaOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AreaOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaOutput[]>(<any>null);
    }

    /**
     * 根据车间id查询所有产线信息
     * @param areaId (optional) 车间ID
     * @return Success
     */
    getLines(areaId: string | null | undefined): Observable<LineOutput[]> {
        let url_ = this.baseUrl + "/api/Tpm/GetLines?";
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLines(<any>response_);
                } catch (e) {
                    return <Observable<LineOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LineOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLines(response: HttpResponseBase): Observable<LineOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LineOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LineOutput[]>(<any>null);
    }

    /**
     * 查询所有设备信息
     * @return Success
     */
    getDevices(): Observable<DeviceOutput[]> {
        let url_ = this.baseUrl + "/api/Tpm/GetDevices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevices(<any>response_);
                } catch (e) {
                    return <Observable<DeviceOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevices(response: HttpResponseBase): Observable<DeviceOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceOutput[]>(<any>null);
    }

    /**
     * @param lineId (optional) 
     * @param lineShowName (optional) portal上面显示的line 名称，需要截取Line1
     * @return Success
     */
    getDevicesByLine(lineId: string | null | undefined, lineShowName: string | null | undefined): Observable<DeviceOutput[]> {
        let url_ = this.baseUrl + "/api/Tpm/GetDevicesByLine?";
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (lineShowName !== undefined)
            url_ += "LineShowName=" + encodeURIComponent("" + lineShowName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesByLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesByLine(<any>response_);
                } catch (e) {
                    return <Observable<DeviceOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevicesByLine(response: HttpResponseBase): Observable<DeviceOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceOutput[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMaintTypes(): Observable<CodeConfigOutput[]> {
        let url_ = this.baseUrl + "/api/Tpm/GetMaintTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintTypes(<any>response_);
                } catch (e) {
                    return <Observable<CodeConfigOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CodeConfigOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaintTypes(response: HttpResponseBase): Observable<CodeConfigOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeConfigOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeConfigOutput[]>(<any>null);
    }
}

@Injectable()
export class TpmAmendmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    queryTpmPlanDetails(input: TpmPlanDetailQueryDto | null | undefined): Observable<TpmPlanDetailDtoOutPut> {
        let url_ = this.baseUrl + "/api/TpmAmendment/QueryTpmPlanDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryTpmPlanDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryTpmPlanDetails(<any>response_);
                } catch (e) {
                    return <Observable<TpmPlanDetailDtoOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<TpmPlanDetailDtoOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processQueryTpmPlanDetails(response: HttpResponseBase): Observable<TpmPlanDetailDtoOutPut> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TpmPlanDetailDtoOutPut.fromJS(resultData200) : new TpmPlanDetailDtoOutPut();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TpmPlanDetailDtoOutPut>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param lineId (optional) 
     * @param deviceId (optional) 
     * @return Success
     */
    getCheckDetail(id: string | null | undefined, lineId: string | null | undefined, deviceId: string | null | undefined): Observable<CheckDetailDto[]> {
        let url_ = this.baseUrl + "/api/TpmAmendment/GetCheckDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckDetail(<any>response_);
                } catch (e) {
                    return <Observable<CheckDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckDetail(response: HttpResponseBase): Observable<CheckDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDetailDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doBySaveCheckList(input: DoBySaveCheckListDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/DoBySaveCheckList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoBySaveCheckList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoBySaveCheckList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDoBySaveCheckList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markCheckDetailComplete(input: MarkCheckDetailCompleteDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/MarkCheckDetailComplete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkCheckDetailComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkCheckDetailComplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkCheckDetailComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    doBySaveBatchCheckList(input: CheckDetailDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/DoBySaveBatchCheckList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoBySaveBatchCheckList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoBySaveBatchCheckList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDoBySaveBatchCheckList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markBatchCheckDetailComplete(input: CheckDetailDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/MarkBatchCheckDetailComplete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkBatchCheckDetailComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkBatchCheckDetailComplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkBatchCheckDetailComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param checkDetailId (optional) 
     * @return Success
     */
    getOpls(checkDetailId: string | null | undefined): Observable<OplDto[]> {
        let url_ = this.baseUrl + "/api/TpmAmendment/GetOpls?";
        if (checkDetailId !== undefined)
            url_ += "checkDetailId=" + encodeURIComponent("" + checkDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpls(<any>response_);
                } catch (e) {
                    return <Observable<OplDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OplDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOpls(response: HttpResponseBase): Observable<OplDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OplDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OplDto[]>(<any>null);
    }

    /**
     * @param entity (optional) 
     * @return Success
     */
    saveOpl(entity: OplDto | null | undefined): Observable<OplDto> {
        let url_ = this.baseUrl + "/api/TpmAmendment/SaveOpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOpl(<any>response_);
                } catch (e) {
                    return <Observable<OplDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OplDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveOpl(response: HttpResponseBase): Observable<OplDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OplDto.fromJS(resultData200) : new OplDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OplDto>(<any>null);
    }

    /**
     * remove opl
     * @param entity (optional) 
     * @return Success
     */
    removeOpl(entity: OplDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/RemoveOpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveOpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveOpl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveOpl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param checkDetailId (optional) 
     * @return Success
     */
    getRepairLogs(checkDetailId: string | null | undefined): Observable<RepairLogDto[]> {
        let url_ = this.baseUrl + "/api/TpmAmendment/GetRepairLogs?";
        if (checkDetailId !== undefined)
            url_ += "checkDetailId=" + encodeURIComponent("" + checkDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepairLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepairLogs(<any>response_);
                } catch (e) {
                    return <Observable<RepairLogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepairLogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepairLogs(response: HttpResponseBase): Observable<RepairLogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepairLogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepairLogDto[]>(<any>null);
    }

    /**
     * @param entity (optional) 
     * @return Success
     */
    saveRepairLog(entity: RepairLogDto | null | undefined): Observable<RepairLogDto> {
        let url_ = this.baseUrl + "/api/TpmAmendment/SaveRepairLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRepairLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRepairLog(<any>response_);
                } catch (e) {
                    return <Observable<RepairLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepairLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveRepairLog(response: HttpResponseBase): Observable<RepairLogDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepairLogDto.fromJS(resultData200) : new RepairLogDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepairLogDto>(<any>null);
    }

    /**
     * remove repairLog
     * @param entity (optional) 
     * @return Success
     */
    removeRepairLog(entity: RepairLogDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/RemoveRepairLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRepairLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRepairLog(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRepairLog(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeTpmPlanDate(input: ChangeTpmPlanDateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmAmendment/ChangeTpmPlanDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeTpmPlanDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeTpmPlanDate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeTpmPlanDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param inputs (optional) 
     * @return Success
     */
    downloadTpmPlanDetail(inputs: TpmPlanDetailQueryDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/TpmAmendment/DownloadTpmPlanDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inputs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTpmPlanDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTpmPlanDetail(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTpmPlanDetail(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param cardNo (optional) 
     * @return Success
     */
    getEmployeeNoByCardNo(cardNo: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/TpmAmendment/GetEmployeeNoByCardNo?";
        if (cardNo !== undefined)
            url_ += "cardNo=" + encodeURIComponent("" + cardNo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeNoByCardNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeNoByCardNo(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeNoByCardNo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param checkDetails (optional) 
     * @return Success
     */
    checkCanDoBy(checkDetails: DoBySaveCheckListDto[] | null | undefined): Observable<DoBySaveCheckListDto> {
        let url_ = this.baseUrl + "/api/TpmAmendment/CheckCanDoBy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkDetails);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCanDoBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCanDoBy(<any>response_);
                } catch (e) {
                    return <Observable<DoBySaveCheckListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoBySaveCheckListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCanDoBy(response: HttpResponseBase): Observable<DoBySaveCheckListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DoBySaveCheckListDto.fromJS(resultData200) : new DoBySaveCheckListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoBySaveCheckListDto>(<any>null);
    }

    /**
     * @param checkDetails (optional) 
     * @return Success
     */
    checkCanCompleteBy(checkDetails: DoBySaveCheckListDto[] | null | undefined): Observable<DoBySaveCheckListDto> {
        let url_ = this.baseUrl + "/api/TpmAmendment/CheckCanCompleteBy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkDetails);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCanCompleteBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCanCompleteBy(<any>response_);
                } catch (e) {
                    return <Observable<DoBySaveCheckListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoBySaveCheckListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCanCompleteBy(response: HttpResponseBase): Observable<DoBySaveCheckListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DoBySaveCheckListDto.fromJS(resultData200) : new DoBySaveCheckListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoBySaveCheckListDto>(<any>null);
    }
}

@Injectable()
export class TpmCalendarServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 查询TPM calendar 需要的数据
     * @param areaId (optional) 车间ID
     * @param valueStreamId (optional) 价值流ID
     * @param lineCode (optional) 线路编号
     * @param deviceName (optional) 设备名称
     * @param dateType (optional) 时间类型 0：所有 1:daily 2:weekly 3:monthly
     * @param viewDate (optional) 当前用户查看的时间范围
     * @return Success
     */
    getTpmCalendarData(areaId: string | null | undefined, valueStreamId: string | null | undefined, lineCode: string | null | undefined, deviceName: string | null | undefined, dateType: number | null | undefined, viewDate: Date | null | undefined): Observable<TpmCalendarOutput[]> {
        let url_ = this.baseUrl + "/api/TpmCalendar/GetTpmCalendarData?";
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        if (lineCode !== undefined)
            url_ += "LineCode=" + encodeURIComponent("" + lineCode) + "&"; 
        if (deviceName !== undefined)
            url_ += "DeviceName=" + encodeURIComponent("" + deviceName) + "&"; 
        if (dateType !== undefined)
            url_ += "DateType=" + encodeURIComponent("" + dateType) + "&"; 
        if (viewDate !== undefined)
            url_ += "ViewDate=" + encodeURIComponent(viewDate ? "" + viewDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTpmCalendarData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTpmCalendarData(<any>response_);
                } catch (e) {
                    return <Observable<TpmCalendarOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TpmCalendarOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTpmCalendarData(response: HttpResponseBase): Observable<TpmCalendarOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TpmCalendarOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TpmCalendarOutput[]>(<any>null);
    }

    /**
     * 编辑Tpm维保项目信息
     * @param detail (optional) 详情信息
     * @return Success
     */
    editTpmCalendar(detail: TpmCalendarDetail | null | undefined): Observable<ResponseBase> {
        let url_ = this.baseUrl + "/api/TpmCalendar/EditTpmCalendar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(detail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditTpmCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditTpmCalendar(<any>response_);
                } catch (e) {
                    return <Observable<ResponseBase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseBase>><any>_observableThrow(response_);
        }));
    }

    protected processEditTpmCalendar(response: HttpResponseBase): Observable<ResponseBase> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseBase.fromJS(resultData200) : new ResponseBase();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseBase>(<any>null);
    }
}

@Injectable()
export class TpmPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param areaId (optional) 
     * @param valueStreamId (optional) 
     * @param lineId (optional) 
     * @param deviceId (optional) 
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    getTpmPlanData(areaId: string | null | undefined, valueStreamId: string | null | undefined, lineId: string | null | undefined, deviceId: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<TpmPlanOutput> {
        let url_ = this.baseUrl + "/api/TpmPlan/GetTpmPlanData?";
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTpmPlanData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTpmPlanData(<any>response_);
                } catch (e) {
                    return <Observable<TpmPlanOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TpmPlanOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTpmPlanData(response: HttpResponseBase): Observable<TpmPlanOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TpmPlanOutput.fromJS(resultData200) : new TpmPlanOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TpmPlanOutput>(<any>null);
    }

    /**
     * @return Success
     */
    removeTpmPlan(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/RemoveTpmPlan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTpmPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTpmPlan(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTpmPlan(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    publishOrFreezeTpmPlan(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/PublishOrFreezeTpmPlan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishOrFreezeTpmPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishOrFreezeTpmPlan(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishOrFreezeTpmPlan(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTpmPlanHistoryData(id: string | null | undefined): Observable<TpmPlanHistoryOutput[]> {
        let url_ = this.baseUrl + "/api/TpmPlan/GetTpmPlanHistoryData?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTpmPlanHistoryData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTpmPlanHistoryData(<any>response_);
                } catch (e) {
                    return <Observable<TpmPlanHistoryOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TpmPlanHistoryOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTpmPlanHistoryData(response: HttpResponseBase): Observable<TpmPlanHistoryOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TpmPlanHistoryOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TpmPlanHistoryOutput[]>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param importedExcel (optional) 
     * @return Success
     */
    importTpmPlan(deviceId: string | null | undefined, importedExcel: FileParameter | null | undefined): Observable<ValidationResultModel[]> {
        let url_ = this.baseUrl + "/api/TpmPlan/ImportTpmPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (deviceId !== null && deviceId !== undefined)
            content_.append("DeviceId", deviceId.toString());
        if (importedExcel !== null && importedExcel !== undefined)
            content_.append("importedExcel", importedExcel.data, importedExcel.fileName ? importedExcel.fileName : "importedExcel");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportTpmPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTpmPlan(<any>response_);
                } catch (e) {
                    return <Observable<ValidationResultModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValidationResultModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processImportTpmPlan(response: HttpResponseBase): Observable<ValidationResultModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValidationResultModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValidationResultModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param pageIndex (optional) 分页，当前页数
     * @param pageSize (optional) 分页，当前每页多少条数据
     * @return Success
     */
    getTpmPlanDetails(id: string | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<TpmPlanDetailOutput> {
        let url_ = this.baseUrl + "/api/TpmPlan/GetTpmPlanDetails?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTpmPlanDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTpmPlanDetails(<any>response_);
                } catch (e) {
                    return <Observable<TpmPlanDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TpmPlanDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTpmPlanDetails(response: HttpResponseBase): Observable<TpmPlanDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TpmPlanDetailOutput.fromJS(resultData200) : new TpmPlanDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TpmPlanDetailOutput>(<any>null);
    }

    /**
     * @return Success
     */
    removeTpmPlanDetails(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/RemoveTpmPlanDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTpmPlanDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTpmPlanDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTpmPlanDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    downloadStandardTemplate(): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/DownloadStandardTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadStandardTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadStandardTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadStandardTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param entity (optional) 
     * @return Success
     */
    saveTpmPlanItemDetails(entity: TpmPlanDetailOutputModel | null | undefined): Observable<TpmPlanDetailOutputModel> {
        let url_ = this.baseUrl + "/api/TpmPlan/SaveTpmPlanItemDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTpmPlanItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTpmPlanItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<TpmPlanDetailOutputModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TpmPlanDetailOutputModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveTpmPlanItemDetails(response: HttpResponseBase): Observable<TpmPlanDetailOutputModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TpmPlanDetailOutputModel.fromJS(resultData200) : new TpmPlanDetailOutputModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TpmPlanDetailOutputModel>(<any>null);
    }

    /**
     * @param tpmPlanDetailsId (optional) 
     * @param files (optional) 
     * @param id (optional) ID
     * @param name (optional) name
     * @return Success
     */
    uploadFile(tpmPlanDetailsId: string | null | undefined, files: IFormFile[] | null | undefined, id: string | null | undefined, name: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/UploadFile?";
        if (tpmPlanDetailsId !== undefined)
            url_ += "tpmPlanDetailsId=" + encodeURIComponent("" + tpmPlanDetailsId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 导出excel
     * @param areaId (optional) 区域Id
     * @param valueStreamId (optional) 价值流ID
     * @param lineId (optional) 产线ID
     * @param deviceId (optional) 设备ID,正常来说，一个设备ID参数就够了，因为这是唯一的
     * @param year (optional) 年份
     * @param month (optional) 月份，1-12
     * @return Success
     */
    exportTpmDetailToExcel(areaId: string | null | undefined, valueStreamId: string | null | undefined, lineId: string | null | undefined, deviceId: string | null | undefined, year: number | null | undefined, month: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/ExportTpmDetailToExcel?";
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&"; 
        if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTpmDetailToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTpmDetailToExcel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExportTpmDetailToExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 预览excel
     * @param areaId (optional) 区域Id
     * @param valueStreamId (optional) 价值流ID
     * @param lineId (optional) 产线ID
     * @param deviceId (optional) 设备ID,正常来说，一个设备ID参数就够了，因为这是唯一的
     * @param year (optional) 年份
     * @param month (optional) 月份，1-12
     * @return Success
     */
    previewExcel(areaId: string | null | undefined, valueStreamId: string | null | undefined, lineId: string | null | undefined, deviceId: string | null | undefined, year: number | null | undefined, month: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TpmPlan/PreviewExcel?";
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        if (valueStreamId !== undefined)
            url_ += "ValueStreamId=" + encodeURIComponent("" + valueStreamId) + "&"; 
        if (lineId !== undefined)
            url_ += "LineId=" + encodeURIComponent("" + lineId) + "&"; 
        if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&"; 
        if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&"; 
        if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewExcel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPreviewExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ValueStreamServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param name (optional) 价值流名称
     * @param code (optional) 价值流代码
     * @param status (optional) 状态
     * @param plantId (optional) 所属工厂Id
     * @param areaId (optional) 所属车间Id
     * @return Success
     */
    queryValueStreams(id: string | null | undefined, name: string | null | undefined, code: string | null | undefined, status: number | null | undefined, plantId: string | null | undefined, areaId: string | null | undefined): Observable<ValueStreamOutput[]> {
        let url_ = this.baseUrl + "/api/ValueStream/QueryValueStreams?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (plantId !== undefined)
            url_ += "PlantId=" + encodeURIComponent("" + plantId) + "&"; 
        if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryValueStreams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryValueStreams(<any>response_);
                } catch (e) {
                    return <Observable<ValueStreamOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueStreamOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryValueStreams(response: HttpResponseBase): Observable<ValueStreamOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValueStreamOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueStreamOutput[]>(<any>null);
    }

    /**
     * save value stream
     * @param entity (optional) value stream
     * @return Success
     */
    saveValueStream(entity: ValueStreamOutput | null | undefined): Observable<ValueStreamOutput> {
        let url_ = this.baseUrl + "/api/ValueStream/SaveValueStream";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveValueStream(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveValueStream(<any>response_);
                } catch (e) {
                    return <Observable<ValueStreamOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueStreamOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSaveValueStream(response: HttpResponseBase): Observable<ValueStreamOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ValueStreamOutput.fromJS(resultData200) : new ValueStreamOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueStreamOutput>(<any>null);
    }

    /**
     * remove value stream
     * @param id id of value stream
     * @return Success
     */
    removeValueStream(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ValueStream/RemoveValueStream/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveValueStream(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveValueStream(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveValueStream(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * get all value stream statuses
     * @return Success
     */
    getValueStreamStatuses(): Observable<StatusEntity[]> {
        let url_ = this.baseUrl + "/api/ValueStream/GetValueStreamStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValueStreamStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValueStreamStatuses(<any>response_);
                } catch (e) {
                    return <Observable<StatusEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetValueStreamStatuses(response: HttpResponseBase): Observable<StatusEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusEntity[]>(<any>null);
    }
}

export class UserEntity implements IUserEntity {
    id!: number | undefined;
    name!: string | undefined;
    password!: string | undefined;
    passwordSalt!: string | undefined;
    firstName!: string | undefined;
    secondName!: string | undefined;
    mail!: string | undefined;
    mobileNo!: string | undefined;
    phoneNo!: string | undefined;
    expireDate!: Date | undefined;
    roles!: RoleEntity[] | undefined;
    employeeNo!: string | undefined;
    plantId!: string | undefined;
    plantName!: string | undefined;
    status!: number | undefined;
    statusName!: string | undefined;
    isDeleted!: boolean | undefined;
    updatedOn!: Date | undefined;

    constructor(data?: IUserEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.password = data["Password"];
            this.passwordSalt = data["PasswordSalt"];
            this.firstName = data["FirstName"];
            this.secondName = data["SecondName"];
            this.mail = data["Mail"];
            this.mobileNo = data["MobileNo"];
            this.phoneNo = data["PhoneNo"];
            this.expireDate = data["ExpireDate"] ? new Date(data["ExpireDate"].toString()) : <any>undefined;
            if (data["Roles"] && data["Roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["Roles"])
                    this.roles!.push(RoleEntity.fromJS(item));
            }
            this.employeeNo = data["EmployeeNo"];
            this.plantId = data["PlantId"];
            this.plantName = data["PlantName"];
            this.status = data["Status"];
            this.statusName = data["StatusName"];
            this.isDeleted = data["IsDeleted"];
            this.updatedOn = data["UpdatedOn"] ? new Date(data["UpdatedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserEntity {
        data = typeof data === 'object' ? data : {};
        let result = new UserEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Password"] = this.password;
        data["PasswordSalt"] = this.passwordSalt;
        data["FirstName"] = this.firstName;
        data["SecondName"] = this.secondName;
        data["Mail"] = this.mail;
        data["MobileNo"] = this.mobileNo;
        data["PhoneNo"] = this.phoneNo;
        data["ExpireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item.toJSON());
        }
        data["EmployeeNo"] = this.employeeNo;
        data["PlantId"] = this.plantId;
        data["PlantName"] = this.plantName;
        data["Status"] = this.status;
        data["StatusName"] = this.statusName;
        data["IsDeleted"] = this.isDeleted;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserEntity {
    id: number | undefined;
    name: string | undefined;
    password: string | undefined;
    passwordSalt: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    mail: string | undefined;
    mobileNo: string | undefined;
    phoneNo: string | undefined;
    expireDate: Date | undefined;
    roles: RoleEntity[] | undefined;
    employeeNo: string | undefined;
    plantId: string | undefined;
    plantName: string | undefined;
    status: number | undefined;
    statusName: string | undefined;
    isDeleted: boolean | undefined;
    updatedOn: Date | undefined;
}

export class RoleEntity implements IRoleEntity {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IRoleEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.description = data["Description"];
        }
    }

    static fromJS(data: any): RoleEntity {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        return data; 
    }
}

export interface IRoleEntity {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
}

export class FunctionGroupEntity implements IFunctionGroupEntity {
    role!: RoleEntity | undefined;
    groupName!: string | undefined;
    functionList!: FunctionEntity[] | undefined;
    chineseGroupName!: string | undefined;

    constructor(data?: IFunctionGroupEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["Role"] ? RoleEntity.fromJS(data["Role"]) : <any>undefined;
            this.groupName = data["GroupName"];
            if (data["FunctionList"] && data["FunctionList"].constructor === Array) {
                this.functionList = [] as any;
                for (let item of data["FunctionList"])
                    this.functionList!.push(FunctionEntity.fromJS(item));
            }
            this.chineseGroupName = data["ChineseGroupName"];
        }
    }

    static fromJS(data: any): FunctionGroupEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionGroupEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["GroupName"] = this.groupName;
        if (this.functionList && this.functionList.constructor === Array) {
            data["FunctionList"] = [];
            for (let item of this.functionList)
                data["FunctionList"].push(item.toJSON());
        }
        data["ChineseGroupName"] = this.chineseGroupName;
        return data; 
    }
}

export interface IFunctionGroupEntity {
    role: RoleEntity | undefined;
    groupName: string | undefined;
    functionList: FunctionEntity[] | undefined;
    chineseGroupName: string | undefined;
}

export class FunctionEntity implements IFunctionEntity {
    id!: number | undefined;
    menuId!: number | undefined;
    name!: string | undefined;
    group!: string | undefined;
    description!: string | undefined;
    checked!: boolean | undefined;
    chineseName!: string | undefined;
    position!: number | undefined;

    constructor(data?: IFunctionEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.menuId = data["MenuId"];
            this.name = data["Name"];
            this.group = data["Group"];
            this.description = data["Description"];
            this.checked = data["Checked"];
            this.chineseName = data["ChineseName"];
            this.position = data["Position"];
        }
    }

    static fromJS(data: any): FunctionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["MenuId"] = this.menuId;
        data["Name"] = this.name;
        data["Group"] = this.group;
        data["Description"] = this.description;
        data["Checked"] = this.checked;
        data["ChineseName"] = this.chineseName;
        data["Position"] = this.position;
        return data; 
    }
}

export interface IFunctionEntity {
    id: number | undefined;
    menuId: number | undefined;
    name: string | undefined;
    group: string | undefined;
    description: string | undefined;
    checked: boolean | undefined;
    chineseName: string | undefined;
    position: number | undefined;
}

export class StatusEntity implements IStatusEntity {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IStatusEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): StatusEntity {
        data = typeof data === 'object' ? data : {};
        let result = new StatusEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IStatusEntity {
    id: number | undefined;
    name: string | undefined;
}

export class NameValueDto implements INameValueDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        return data; 
    }
}

export interface INameValueDto {
    id: string | undefined;
    name: string | undefined;
}

export class AreaOutput implements IAreaOutput {
    /** ID */
    id!: string | undefined;
    /** 车间名称 */
    areaName!: string | undefined;
    /** 车间代码 */
    code!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    /** 状态 */
    status!: number | undefined;
    statusName!: string | undefined;
    /** 所属工厂Id */
    plantId!: string | undefined;
    plantName!: string | undefined;
    mapId!: string | undefined;
    updatedOn!: Date | undefined;
    updatedBy!: string | undefined;
    isDeleted!: boolean | undefined;

    constructor(data?: IAreaOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.areaName = data["AreaName"];
            this.code = data["Code"];
            this.description = data["Description"];
            this.status = data["Status"];
            this.statusName = data["StatusName"];
            this.plantId = data["PlantId"];
            this.plantName = data["PlantName"];
            this.mapId = data["MapId"];
            this.updatedOn = data["UpdatedOn"] ? new Date(data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedBy = data["UpdatedBy"];
            this.isDeleted = data["IsDeleted"];
        }
    }

    static fromJS(data: any): AreaOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AreaOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["AreaName"] = this.areaName;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["Status"] = this.status;
        data["StatusName"] = this.statusName;
        data["PlantId"] = this.plantId;
        data["PlantName"] = this.plantName;
        data["MapId"] = this.mapId;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedBy"] = this.updatedBy;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IAreaOutput {
    /** ID */
    id: string | undefined;
    /** 车间名称 */
    areaName: string | undefined;
    /** 车间代码 */
    code: string | undefined;
    /** 描述 */
    description: string | undefined;
    /** 状态 */
    status: number | undefined;
    statusName: string | undefined;
    /** 所属工厂Id */
    plantId: string | undefined;
    plantName: string | undefined;
    mapId: string | undefined;
    updatedOn: Date | undefined;
    updatedBy: string | undefined;
    isDeleted: boolean | undefined;
}

export class AreaUserDto implements IAreaUserDto {
    /** ID */
    id!: string | undefined;
    /** 车间Id */
    areaId!: string | undefined;
    users!: UserEntity[] | undefined;

    constructor(data?: IAreaUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.areaId = data["AreaId"];
            if (data["Users"] && data["Users"].constructor === Array) {
                this.users = [] as any;
                for (let item of data["Users"])
                    this.users!.push(UserEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AreaUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["AreaId"] = this.areaId;
        if (this.users && this.users.constructor === Array) {
            data["Users"] = [];
            for (let item of this.users)
                data["Users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAreaUserDto {
    /** ID */
    id: string | undefined;
    /** 车间Id */
    areaId: string | undefined;
    users: UserEntity[] | undefined;
}

export class FileUploadOutput implements IFileUploadOutput {
    /** 返回的附件表主键 */
    guid!: string | undefined;
    /** 是否成功 */
    isSuccess!: boolean | undefined;
    /** 备注信息 */
    msg!: string | undefined;

    constructor(data?: IFileUploadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.guid = data["Guid"];
            this.isSuccess = data["IsSuccess"];
            this.msg = data["Msg"];
        }
    }

    static fromJS(data: any): FileUploadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Guid"] = this.guid;
        data["IsSuccess"] = this.isSuccess;
        data["Msg"] = this.msg;
        return data; 
    }
}

export interface IFileUploadOutput {
    /** 返回的附件表主键 */
    guid: string | undefined;
    /** 是否成功 */
    isSuccess: boolean | undefined;
    /** 备注信息 */
    msg: string | undefined;
}

export class FileInfoDto implements IFileInfoDto {
    fileName!: string | undefined;
    fileData!: string | undefined;
    size!: number | undefined;
    type!: string | undefined;

    constructor(data?: IFileInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["FileName"];
            this.fileData = data["FileData"];
            this.size = data["Size"];
            this.type = data["Type"];
        }
    }

    static fromJS(data: any): FileInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileName"] = this.fileName;
        data["FileData"] = this.fileData;
        data["Size"] = this.size;
        data["Type"] = this.type;
        return data; 
    }
}

export interface IFileInfoDto {
    fileName: string | undefined;
    fileData: string | undefined;
    size: number | undefined;
    type: string | undefined;
}

/** 审计日志输出信息 */
export class AuditLogOutput implements IAuditLogOutput {
    models!: AuditLogOutputModel[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: IAuditLogOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Models"] && data["Models"].constructor === Array) {
                this.models = [] as any;
                for (let item of data["Models"])
                    this.models!.push(AuditLogOutputModel.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): AuditLogOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.models && this.models.constructor === Array) {
            data["Models"] = [];
            for (let item of this.models)
                data["Models"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

/** 审计日志输出信息 */
export interface IAuditLogOutput {
    models: AuditLogOutputModel[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class AuditLogOutputModel implements IAuditLogOutputModel {
    /** ID */
    id!: string | undefined;
    /** 日志类型 枚举LogType。1:审计日志 2:异常日志 3:业务日志 */
    logType!: number | undefined;
    /** 开始时间 */
    time!: string | undefined;
    /** 用户名 */
    userName!: string | undefined;
    /** 工号 */
    userNo!: string | undefined;
    /** 请求地址 */
    requestUrl!: string | undefined;
    /** 服务名 */
    service!: string | undefined;
    /** 方法名 */
    action!: string | undefined;
    /** 持续时间，毫秒 */
    duration!: number | undefined;
    /** IP地址 */
    iPAddress!: string | undefined;
    /** 客户端User-Agent */
    clientBrowser!: string | undefined;
    /** 请求参数 */
    requestParam!: string | undefined;
    /** 响应参数 */
    responseParam!: string | undefined;
    /** 异常信息 */
    exception!: string | undefined;
    /** 自定义数据(描述) */
    customContent!: string | undefined;

    constructor(data?: IAuditLogOutputModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.logType = data["LogType"];
            this.time = data["Time"];
            this.userName = data["UserName"];
            this.userNo = data["UserNo"];
            this.requestUrl = data["RequestUrl"];
            this.service = data["Service"];
            this.action = data["Action"];
            this.duration = data["Duration"];
            this.iPAddress = data["IPAddress"];
            this.clientBrowser = data["ClientBrowser"];
            this.requestParam = data["RequestParam"];
            this.responseParam = data["ResponseParam"];
            this.exception = data["Exception"];
            this.customContent = data["CustomContent"];
        }
    }

    static fromJS(data: any): AuditLogOutputModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogOutputModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["LogType"] = this.logType;
        data["Time"] = this.time;
        data["UserName"] = this.userName;
        data["UserNo"] = this.userNo;
        data["RequestUrl"] = this.requestUrl;
        data["Service"] = this.service;
        data["Action"] = this.action;
        data["Duration"] = this.duration;
        data["IPAddress"] = this.iPAddress;
        data["ClientBrowser"] = this.clientBrowser;
        data["RequestParam"] = this.requestParam;
        data["ResponseParam"] = this.responseParam;
        data["Exception"] = this.exception;
        data["CustomContent"] = this.customContent;
        return data; 
    }
}

export interface IAuditLogOutputModel {
    /** ID */
    id: string | undefined;
    /** 日志类型 枚举LogType。1:审计日志 2:异常日志 3:业务日志 */
    logType: number | undefined;
    /** 开始时间 */
    time: string | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 工号 */
    userNo: string | undefined;
    /** 请求地址 */
    requestUrl: string | undefined;
    /** 服务名 */
    service: string | undefined;
    /** 方法名 */
    action: string | undefined;
    /** 持续时间，毫秒 */
    duration: number | undefined;
    /** IP地址 */
    iPAddress: string | undefined;
    /** 客户端User-Agent */
    clientBrowser: string | undefined;
    /** 请求参数 */
    requestParam: string | undefined;
    /** 响应参数 */
    responseParam: string | undefined;
    /** 异常信息 */
    exception: string | undefined;
    /** 自定义数据(描述) */
    customContent: string | undefined;
}

export class LoginEntity implements ILoginEntity {
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILoginEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["UserName"];
            this.password = data["Password"];
        }
    }

    static fromJS(data: any): LoginEntity {
        data = typeof data === 'object' ? data : {};
        let result = new LoginEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        return data; 
    }
}

export interface ILoginEntity {
    userName: string | undefined;
    password: string | undefined;
}

/** LoginResponseModel */
export class LoginResponseModel implements ILoginResponseModel {
    /** Success */
    success!: boolean | undefined;
    /** Message */
    message!: string | undefined;
    /** User */
    user!: UserEntity | undefined;
    /** Token */
    token!: string | undefined;
    /** RefreshToken */
    refreshToken!: string | undefined;

    constructor(data?: ILoginResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["Success"];
            this.message = data["Message"];
            this.user = data["User"] ? UserEntity.fromJS(data["User"]) : <any>undefined;
            this.token = data["Token"];
            this.refreshToken = data["RefreshToken"];
        }
    }

    static fromJS(data: any): LoginResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Success"] = this.success;
        data["Message"] = this.message;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["Token"] = this.token;
        data["RefreshToken"] = this.refreshToken;
        return data; 
    }
}

/** LoginResponseModel */
export interface ILoginResponseModel {
    /** Success */
    success: boolean | undefined;
    /** Message */
    message: string | undefined;
    /** User */
    user: UserEntity | undefined;
    /** Token */
    token: string | undefined;
    /** RefreshToken */
    refreshToken: string | undefined;
}

export class DeviceUsersOutPut implements IDeviceUsersOutPut {
    serviceList!: UserEntity[] | undefined;
    engineerList!: UserEntity[] | undefined;

    constructor(data?: IDeviceUsersOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ServiceList"] && data["ServiceList"].constructor === Array) {
                this.serviceList = [] as any;
                for (let item of data["ServiceList"])
                    this.serviceList!.push(UserEntity.fromJS(item));
            }
            if (data["EngineerList"] && data["EngineerList"].constructor === Array) {
                this.engineerList = [] as any;
                for (let item of data["EngineerList"])
                    this.engineerList!.push(UserEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceUsersOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceUsersOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.serviceList && this.serviceList.constructor === Array) {
            data["ServiceList"] = [];
            for (let item of this.serviceList)
                data["ServiceList"].push(item.toJSON());
        }
        if (this.engineerList && this.engineerList.constructor === Array) {
            data["EngineerList"] = [];
            for (let item of this.engineerList)
                data["EngineerList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceUsersOutPut {
    serviceList: UserEntity[] | undefined;
    engineerList: UserEntity[] | undefined;
}

export class DeviceDetailOutput implements IDeviceDetailOutput {
    dtos!: DeviceDetailDto[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: IDeviceDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Dtos"] && data["Dtos"].constructor === Array) {
                this.dtos = [] as any;
                for (let item of data["Dtos"])
                    this.dtos!.push(DeviceDetailDto.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): DeviceDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dtos && this.dtos.constructor === Array) {
            data["Dtos"] = [];
            for (let item of this.dtos)
                data["Dtos"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface IDeviceDetailOutput {
    dtos: DeviceDetailDto[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class DeviceDetailDto implements IDeviceDetailDto {
    id!: string | undefined;
    updatedOn!: string | undefined;
    updatedBy!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    plantId!: string | undefined;
    plantName!: string | undefined;
    lineId!: string | undefined;
    lineName!: string | undefined;
    areaId!: string | undefined;
    areaName!: string | undefined;
    valueStreamId!: string | undefined;
    valueStreamName!: string | undefined;
    stationId!: string | undefined;
    stationName!: string | undefined;
    statusName!: string | undefined;
    status!: string | undefined;
    rleaseDate!: string | undefined;
    serviceList!: UserEntity[] | undefined;
    engineerList!: UserEntity[] | undefined;

    constructor(data?: IDeviceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.updatedOn = data["UpdatedOn"];
            this.updatedBy = data["UpdatedBy"];
            this.code = data["Code"];
            this.name = data["Name"];
            this.description = data["Description"];
            this.plantId = data["PlantId"];
            this.plantName = data["PlantName"];
            this.lineId = data["LineId"];
            this.lineName = data["LineName"];
            this.areaId = data["AreaId"];
            this.areaName = data["AreaName"];
            this.valueStreamId = data["ValueStreamId"];
            this.valueStreamName = data["ValueStreamName"];
            this.stationId = data["StationId"];
            this.stationName = data["StationName"];
            this.statusName = data["StatusName"];
            this.status = data["Status"];
            this.rleaseDate = data["RleaseDate"];
            if (data["ServiceList"] && data["ServiceList"].constructor === Array) {
                this.serviceList = [] as any;
                for (let item of data["ServiceList"])
                    this.serviceList!.push(UserEntity.fromJS(item));
            }
            if (data["EngineerList"] && data["EngineerList"].constructor === Array) {
                this.engineerList = [] as any;
                for (let item of data["EngineerList"])
                    this.engineerList!.push(UserEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UpdatedOn"] = this.updatedOn;
        data["UpdatedBy"] = this.updatedBy;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["PlantId"] = this.plantId;
        data["PlantName"] = this.plantName;
        data["LineId"] = this.lineId;
        data["LineName"] = this.lineName;
        data["AreaId"] = this.areaId;
        data["AreaName"] = this.areaName;
        data["ValueStreamId"] = this.valueStreamId;
        data["ValueStreamName"] = this.valueStreamName;
        data["StationId"] = this.stationId;
        data["StationName"] = this.stationName;
        data["StatusName"] = this.statusName;
        data["Status"] = this.status;
        data["RleaseDate"] = this.rleaseDate;
        if (this.serviceList && this.serviceList.constructor === Array) {
            data["ServiceList"] = [];
            for (let item of this.serviceList)
                data["ServiceList"].push(item.toJSON());
        }
        if (this.engineerList && this.engineerList.constructor === Array) {
            data["EngineerList"] = [];
            for (let item of this.engineerList)
                data["EngineerList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceDetailDto {
    id: string | undefined;
    updatedOn: string | undefined;
    updatedBy: string | undefined;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    plantId: string | undefined;
    plantName: string | undefined;
    lineId: string | undefined;
    lineName: string | undefined;
    areaId: string | undefined;
    areaName: string | undefined;
    valueStreamId: string | undefined;
    valueStreamName: string | undefined;
    stationId: string | undefined;
    stationName: string | undefined;
    statusName: string | undefined;
    status: string | undefined;
    rleaseDate: string | undefined;
    serviceList: UserEntity[] | undefined;
    engineerList: UserEntity[] | undefined;
}

export class LineEntity implements ILineEntity {
    id!: string | undefined;
    createdOn!: Date | undefined;
    createdBy!: string | undefined;
    updatedOn!: Date | undefined;
    updatedBy!: string | undefined;
    plantId!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    isNewLine!: boolean | undefined;
    description!: string | undefined;
    plantCode!: string | undefined;
    plantName!: string | undefined;
    processId!: string | undefined;
    processName!: string | undefined;
    isDeleted!: boolean | undefined;

    constructor(data?: ILineEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.createdOn = data["CreatedOn"] ? new Date(data["CreatedOn"].toString()) : <any>undefined;
            this.createdBy = data["CreatedBy"];
            this.updatedOn = data["UpdatedOn"] ? new Date(data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedBy = data["UpdatedBy"];
            this.plantId = data["PlantId"];
            this.code = data["Code"];
            this.name = data["Name"];
            this.isActive = data["IsActive"];
            this.isNewLine = data["IsNewLine"];
            this.description = data["Description"];
            this.plantCode = data["PlantCode"];
            this.plantName = data["PlantName"];
            this.processId = data["ProcessId"];
            this.processName = data["ProcessName"];
            this.isDeleted = data["IsDeleted"];
        }
    }

    static fromJS(data: any): LineEntity {
        data = typeof data === 'object' ? data : {};
        let result = new LineEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedBy"] = this.createdBy;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedBy"] = this.updatedBy;
        data["PlantId"] = this.plantId;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsNewLine"] = this.isNewLine;
        data["Description"] = this.description;
        data["PlantCode"] = this.plantCode;
        data["PlantName"] = this.plantName;
        data["ProcessId"] = this.processId;
        data["ProcessName"] = this.processName;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface ILineEntity {
    id: string | undefined;
    createdOn: Date | undefined;
    createdBy: string | undefined;
    updatedOn: Date | undefined;
    updatedBy: string | undefined;
    plantId: string | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    isNewLine: boolean | undefined;
    description: string | undefined;
    plantCode: string | undefined;
    plantName: string | undefined;
    processId: string | undefined;
    processName: string | undefined;
    isDeleted: boolean | undefined;
}

export class LineDetailOutput implements ILineDetailOutput {
    id!: string | undefined;
    createdOn!: Date | undefined;
    createdBy!: string | undefined;
    updatedOn!: Date | undefined;
    updatedBy!: string | undefined;
    plantId!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    isNewLine!: boolean | undefined;
    description!: string | undefined;
    plantCode!: string | undefined;
    plantName!: string | undefined;
    areaId!: string | undefined;
    areaCode!: string | undefined;
    areaName!: string | undefined;
    valueStreamId!: string | undefined;
    valueStreamCode!: string | undefined;
    valueStreamName!: string | undefined;
    mapId!: string | undefined;
    /** 状态 */
    status!: number | undefined;
    statusName!: string | undefined;
    wI!: string | undefined;
    isDeleted!: boolean | undefined;

    constructor(data?: ILineDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.createdOn = data["CreatedOn"] ? new Date(data["CreatedOn"].toString()) : <any>undefined;
            this.createdBy = data["CreatedBy"];
            this.updatedOn = data["UpdatedOn"] ? new Date(data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedBy = data["UpdatedBy"];
            this.plantId = data["PlantId"];
            this.code = data["Code"];
            this.name = data["Name"];
            this.isActive = data["IsActive"];
            this.isNewLine = data["IsNewLine"];
            this.description = data["Description"];
            this.plantCode = data["PlantCode"];
            this.plantName = data["PlantName"];
            this.areaId = data["AreaId"];
            this.areaCode = data["AreaCode"];
            this.areaName = data["AreaName"];
            this.valueStreamId = data["ValueStreamId"];
            this.valueStreamCode = data["ValueStreamCode"];
            this.valueStreamName = data["ValueStreamName"];
            this.mapId = data["MapId"];
            this.status = data["Status"];
            this.statusName = data["StatusName"];
            this.wI = data["WI"];
            this.isDeleted = data["IsDeleted"];
        }
    }

    static fromJS(data: any): LineDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LineDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedBy"] = this.createdBy;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedBy"] = this.updatedBy;
        data["PlantId"] = this.plantId;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsNewLine"] = this.isNewLine;
        data["Description"] = this.description;
        data["PlantCode"] = this.plantCode;
        data["PlantName"] = this.plantName;
        data["AreaId"] = this.areaId;
        data["AreaCode"] = this.areaCode;
        data["AreaName"] = this.areaName;
        data["ValueStreamId"] = this.valueStreamId;
        data["ValueStreamCode"] = this.valueStreamCode;
        data["ValueStreamName"] = this.valueStreamName;
        data["MapId"] = this.mapId;
        data["Status"] = this.status;
        data["StatusName"] = this.statusName;
        data["WI"] = this.wI;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface ILineDetailOutput {
    id: string | undefined;
    createdOn: Date | undefined;
    createdBy: string | undefined;
    updatedOn: Date | undefined;
    updatedBy: string | undefined;
    plantId: string | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    isNewLine: boolean | undefined;
    description: string | undefined;
    plantCode: string | undefined;
    plantName: string | undefined;
    areaId: string | undefined;
    areaCode: string | undefined;
    areaName: string | undefined;
    valueStreamId: string | undefined;
    valueStreamCode: string | undefined;
    valueStreamName: string | undefined;
    mapId: string | undefined;
    /** 状态 */
    status: number | undefined;
    statusName: string | undefined;
    wI: string | undefined;
    isDeleted: boolean | undefined;
}

export class LineUserDto implements ILineUserDto {
    /** ID */
    id!: string | undefined;
    /** 产线Id */
    lineId!: string | undefined;
    /** 类型 */
    type!: number | undefined;
    users!: UserEntity[] | undefined;

    constructor(data?: ILineUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.lineId = data["LineId"];
            this.type = data["Type"];
            if (data["Users"] && data["Users"].constructor === Array) {
                this.users = [] as any;
                for (let item of data["Users"])
                    this.users!.push(UserEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LineUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LineUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["LineId"] = this.lineId;
        data["Type"] = this.type;
        if (this.users && this.users.constructor === Array) {
            data["Users"] = [];
            for (let item of this.users)
                data["Users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILineUserDto {
    /** ID */
    id: string | undefined;
    /** 产线Id */
    lineId: string | undefined;
    /** 类型 */
    type: number | undefined;
    users: UserEntity[] | undefined;
}

export class DeviceAndStationOutput implements IDeviceAndStationOutput {
    /** ID */
    id!: string | undefined;
    /** 是否在line-edit上面 mapper过了 */
    isMapped!: boolean | undefined;
    /** 设备名称 */
    deviceName!: string | undefined;
    /** 站点名称 */
    stationName!: string | undefined;
    /** 正向旋转角度 */
    transform!: number | undefined;
    /** Size信息 */
    size!: SizeInfo | undefined;
    /** Position信息 */
    position!: PositionInfo | undefined;
    /** LineEditShowName */
    lineEditShowName!: string | undefined;
    /** 设备编号 */
    deviceCode!: string | undefined;

    constructor(data?: IDeviceAndStationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.isMapped = data["IsMapped"];
            this.deviceName = data["DeviceName"];
            this.stationName = data["StationName"];
            this.transform = data["Transform"];
            this.size = data["Size"] ? SizeInfo.fromJS(data["Size"]) : <any>undefined;
            this.position = data["Position"] ? PositionInfo.fromJS(data["Position"]) : <any>undefined;
            this.lineEditShowName = data["LineEditShowName"];
            this.deviceCode = data["DeviceCode"];
        }
    }

    static fromJS(data: any): DeviceAndStationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAndStationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["IsMapped"] = this.isMapped;
        data["DeviceName"] = this.deviceName;
        data["StationName"] = this.stationName;
        data["Transform"] = this.transform;
        data["Size"] = this.size ? this.size.toJSON() : <any>undefined;
        data["Position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["LineEditShowName"] = this.lineEditShowName;
        data["DeviceCode"] = this.deviceCode;
        return data; 
    }
}

export interface IDeviceAndStationOutput {
    /** ID */
    id: string | undefined;
    /** 是否在line-edit上面 mapper过了 */
    isMapped: boolean | undefined;
    /** 设备名称 */
    deviceName: string | undefined;
    /** 站点名称 */
    stationName: string | undefined;
    /** 正向旋转角度 */
    transform: number | undefined;
    /** Size信息 */
    size: SizeInfo | undefined;
    /** Position信息 */
    position: PositionInfo | undefined;
    /** LineEditShowName */
    lineEditShowName: string | undefined;
    /** 设备编号 */
    deviceCode: string | undefined;
}

export class SizeInfo implements ISizeInfo {
    /** 宽度，必须小写，前台需要 */
    width!: number | undefined;
    /** 高度，必须小写，前台需要 */
    height!: number | undefined;

    constructor(data?: ISizeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): SizeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SizeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ISizeInfo {
    /** 宽度，必须小写，前台需要 */
    width: number | undefined;
    /** 高度，必须小写，前台需要 */
    height: number | undefined;
}

export class PositionInfo implements IPositionInfo {
    /** x坐标，必须小写，前台需要 */
    x!: number | undefined;
    /** y坐标，必须小写，前台需要 */
    y!: number | undefined;

    constructor(data?: IPositionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x = data["x"];
            this.y = data["y"];
        }
    }

    static fromJS(data: any): PositionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PositionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data; 
    }
}

export interface IPositionInfo {
    /** x坐标，必须小写，前台需要 */
    x: number | undefined;
    /** y坐标，必须小写，前台需要 */
    y: number | undefined;
}

export class ResponseBase implements IResponseBase {
    /** 是否成功 */
    isSuccess!: boolean | undefined;
    /** 备注信息 */
    msg!: string | undefined;

    constructor(data?: IResponseBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSuccess = data["IsSuccess"];
            this.msg = data["Msg"];
        }
    }

    static fromJS(data: any): ResponseBase {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsSuccess"] = this.isSuccess;
        data["Msg"] = this.msg;
        return data; 
    }
}

export interface IResponseBase {
    /** 是否成功 */
    isSuccess: boolean | undefined;
    /** 备注信息 */
    msg: string | undefined;
}

export class LineMapImgOutput implements ILineMapImgOutput {
    /** Line的Map背景图 */
    mapImgUrl!: string | undefined;
    /** 是否成功 */
    isSuccess!: boolean | undefined;
    /** 备注信息 */
    msg!: string | undefined;

    constructor(data?: ILineMapImgOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mapImgUrl = data["MapImgUrl"];
            this.isSuccess = data["IsSuccess"];
            this.msg = data["Msg"];
        }
    }

    static fromJS(data: any): LineMapImgOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LineMapImgOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MapImgUrl"] = this.mapImgUrl;
        data["IsSuccess"] = this.isSuccess;
        data["Msg"] = this.msg;
        return data; 
    }
}

export interface ILineMapImgOutput {
    /** Line的Map背景图 */
    mapImgUrl: string | undefined;
    /** 是否成功 */
    isSuccess: boolean | undefined;
    /** 备注信息 */
    msg: string | undefined;
}

export class OplCenterDtoOutPut implements IOplCenterDtoOutPut {
    dtos!: OplCenterDto[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: IOplCenterDtoOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Dtos"] && data["Dtos"].constructor === Array) {
                this.dtos = [] as any;
                for (let item of data["Dtos"])
                    this.dtos!.push(OplCenterDto.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): OplCenterDtoOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new OplCenterDtoOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dtos && this.dtos.constructor === Array) {
            data["Dtos"] = [];
            for (let item of this.dtos)
                data["Dtos"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface IOplCenterDtoOutPut {
    dtos: OplCenterDto[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class OplCenterDto implements IOplCenterDto {
    id!: string | undefined;
    description!: string | undefined;
    status!: string | undefined;
    statusValue!: number | undefined;
    result!: string | undefined;
    comment!: string | undefined;
    closedOn!: string | undefined;
    closedBy!: string | undefined;
    area!: string | undefined;
    valueStream!: string | undefined;
    line!: string | undefined;
    device!: string | undefined;
    createdOn!: string | undefined;
    createdBy!: string | undefined;

    constructor(data?: IOplCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.description = data["Description"];
            this.status = data["Status"];
            this.statusValue = data["StatusValue"];
            this.result = data["Result"];
            this.comment = data["Comment"];
            this.closedOn = data["ClosedOn"];
            this.closedBy = data["ClosedBy"];
            this.area = data["Area"];
            this.valueStream = data["ValueStream"];
            this.line = data["Line"];
            this.device = data["Device"];
            this.createdOn = data["CreatedOn"];
            this.createdBy = data["CreatedBy"];
        }
    }

    static fromJS(data: any): OplCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new OplCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Description"] = this.description;
        data["Status"] = this.status;
        data["StatusValue"] = this.statusValue;
        data["Result"] = this.result;
        data["Comment"] = this.comment;
        data["ClosedOn"] = this.closedOn;
        data["ClosedBy"] = this.closedBy;
        data["Area"] = this.area;
        data["ValueStream"] = this.valueStream;
        data["Line"] = this.line;
        data["Device"] = this.device;
        data["CreatedOn"] = this.createdOn;
        data["CreatedBy"] = this.createdBy;
        return data; 
    }
}

export interface IOplCenterDto {
    id: string | undefined;
    description: string | undefined;
    status: string | undefined;
    statusValue: number | undefined;
    result: string | undefined;
    comment: string | undefined;
    closedOn: string | undefined;
    closedBy: string | undefined;
    area: string | undefined;
    valueStream: string | undefined;
    line: string | undefined;
    device: string | undefined;
    createdOn: string | undefined;
    createdBy: string | undefined;
}

export class AssignOplDto implements IAssignOplDto {
    oplId!: string | undefined;
    employeeNo!: string | undefined;

    constructor(data?: IAssignOplDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oplId = data["OplId"];
            this.employeeNo = data["EmployeeNo"];
        }
    }

    static fromJS(data: any): AssignOplDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignOplDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OplId"] = this.oplId;
        data["EmployeeNo"] = this.employeeNo;
        return data; 
    }
}

export interface IAssignOplDto {
    oplId: string | undefined;
    employeeNo: string | undefined;
}

export class OplDto implements IOplDto {
    id!: string | undefined;
    description!: string | undefined;
    createTime!: string | undefined;
    createdBy!: string | undefined;
    checkDetailId!: string | undefined;
    deviceId!: string | undefined;
    writeLog!: boolean | undefined;

    constructor(data?: IOplDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.description = data["Description"];
            this.createTime = data["CreateTime"];
            this.createdBy = data["CreatedBy"];
            this.checkDetailId = data["CheckDetailId"];
            this.deviceId = data["DeviceId"];
            this.writeLog = data["WriteLog"];
        }
    }

    static fromJS(data: any): OplDto {
        data = typeof data === 'object' ? data : {};
        let result = new OplDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Description"] = this.description;
        data["CreateTime"] = this.createTime;
        data["CreatedBy"] = this.createdBy;
        data["CheckDetailId"] = this.checkDetailId;
        data["DeviceId"] = this.deviceId;
        data["WriteLog"] = this.writeLog;
        return data; 
    }
}

export interface IOplDto {
    id: string | undefined;
    description: string | undefined;
    createTime: string | undefined;
    createdBy: string | undefined;
    checkDetailId: string | undefined;
    deviceId: string | undefined;
    writeLog: boolean | undefined;
}

export class OplDetailSaveDto implements IOplDetailSaveDto {
    id!: string | undefined;
    description!: string | undefined;
    result!: string | undefined;

    constructor(data?: IOplDetailSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.description = data["Description"];
            this.result = data["Result"];
        }
    }

    static fromJS(data: any): OplDetailSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new OplDetailSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Description"] = this.description;
        data["Result"] = this.result;
        return data; 
    }
}

export interface IOplDetailSaveDto {
    id: string | undefined;
    description: string | undefined;
    result: string | undefined;
}

export class OplDetailCompleteDto implements IOplDetailCompleteDto {
    id!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IOplDetailCompleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.comment = data["Comment"];
        }
    }

    static fromJS(data: any): OplDetailCompleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new OplDetailCompleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Comment"] = this.comment;
        return data; 
    }
}

export interface IOplDetailCompleteDto {
    id: string | undefined;
    comment: string | undefined;
}

export class DeleteOrCancelOplDto implements IDeleteOrCancelOplDto {
    id!: string | undefined;
    isDelete!: boolean | undefined;
    reason!: string | undefined;

    constructor(data?: IDeleteOrCancelOplDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.isDelete = data["IsDelete"];
            this.reason = data["Reason"];
        }
    }

    static fromJS(data: any): DeleteOrCancelOplDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteOrCancelOplDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["IsDelete"] = this.isDelete;
        data["Reason"] = this.reason;
        return data; 
    }
}

export interface IDeleteOrCancelOplDto {
    id: string | undefined;
    isDelete: boolean | undefined;
    reason: string | undefined;
}

export class PlantEntity implements IPlantEntity {
    id!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    description!: string | undefined;
    createdOn!: Date | undefined;
    createdBy!: string | undefined;
    updatedOn!: Date | undefined;
    updatedBy!: string | undefined;
    isDeleted!: boolean | undefined;

    constructor(data?: IPlantEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
            this.isActive = data["IsActive"];
            this.description = data["Description"];
            this.createdOn = data["CreatedOn"] ? new Date(data["CreatedOn"].toString()) : <any>undefined;
            this.createdBy = data["CreatedBy"];
            this.updatedOn = data["UpdatedOn"] ? new Date(data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedBy = data["UpdatedBy"];
            this.isDeleted = data["IsDeleted"];
        }
    }

    static fromJS(data: any): PlantEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PlantEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["Description"] = this.description;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedBy"] = this.createdBy;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedBy"] = this.updatedBy;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IPlantEntity {
    id: string | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    description: string | undefined;
    createdOn: Date | undefined;
    createdBy: string | undefined;
    updatedOn: Date | undefined;
    updatedBy: string | undefined;
    isDeleted: boolean | undefined;
}

export class RegistrationEntity implements IRegistrationEntity {
    userName!: string | undefined;
    firstName!: string | undefined;
    secondName!: string | undefined;
    password!: string | undefined;
    confirmPassword!: string | undefined;
    mail!: string | undefined;
    mobileNo!: string | undefined;
    success!: boolean | undefined;
    message!: string | undefined;

    constructor(data?: IRegistrationEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["UserName"];
            this.firstName = data["FirstName"];
            this.secondName = data["SecondName"];
            this.password = data["Password"];
            this.confirmPassword = data["ConfirmPassword"];
            this.mail = data["Mail"];
            this.mobileNo = data["MobileNo"];
            this.success = data["Success"];
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): RegistrationEntity {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["FirstName"] = this.firstName;
        data["SecondName"] = this.secondName;
        data["Password"] = this.password;
        data["ConfirmPassword"] = this.confirmPassword;
        data["Mail"] = this.mail;
        data["MobileNo"] = this.mobileNo;
        data["Success"] = this.success;
        data["Message"] = this.message;
        return data; 
    }
}

export interface IRegistrationEntity {
    userName: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    mail: string | undefined;
    mobileNo: string | undefined;
    success: boolean | undefined;
    message: string | undefined;
}

export class ChangePasswordEntity implements IChangePasswordEntity {
    id!: number | undefined;
    name!: string | undefined;
    oldPassword!: string | undefined;
    newPassword!: string | undefined;
    confirmPassword!: string | undefined;
    success!: boolean | undefined;
    message!: string | undefined;

    constructor(data?: IChangePasswordEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.oldPassword = data["OldPassword"];
            this.newPassword = data["NewPassword"];
            this.confirmPassword = data["ConfirmPassword"];
            this.success = data["Success"];
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): ChangePasswordEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["OldPassword"] = this.oldPassword;
        data["NewPassword"] = this.newPassword;
        data["ConfirmPassword"] = this.confirmPassword;
        data["Success"] = this.success;
        data["Message"] = this.message;
        return data; 
    }
}

export interface IChangePasswordEntity {
    id: number | undefined;
    name: string | undefined;
    oldPassword: string | undefined;
    newPassword: string | undefined;
    confirmPassword: string | undefined;
    success: boolean | undefined;
    message: string | undefined;
}

export class StationDetailOutput implements IStationDetailOutput {
    dtos!: StationDetailDto[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: IStationDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Dtos"] && data["Dtos"].constructor === Array) {
                this.dtos = [] as any;
                for (let item of data["Dtos"])
                    this.dtos!.push(StationDetailDto.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): StationDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StationDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dtos && this.dtos.constructor === Array) {
            data["Dtos"] = [];
            for (let item of this.dtos)
                data["Dtos"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface IStationDetailOutput {
    dtos: StationDetailDto[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class StationDetailDto implements IStationDetailDto {
    id!: string | undefined;
    updatedOn!: string | undefined;
    updatedBy!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    plantId!: string | undefined;
    plantName!: string | undefined;
    lineId!: string | undefined;
    lineName!: string | undefined;
    areaId!: string | undefined;
    areaName!: string | undefined;
    valueStreamId!: string | undefined;
    valueStreamName!: string | undefined;
    statusName!: string | undefined;
    status!: string | undefined;

    constructor(data?: IStationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.updatedOn = data["UpdatedOn"];
            this.updatedBy = data["UpdatedBy"];
            this.code = data["Code"];
            this.name = data["Name"];
            this.description = data["Description"];
            this.plantId = data["PlantId"];
            this.plantName = data["PlantName"];
            this.lineId = data["LineId"];
            this.lineName = data["LineName"];
            this.areaId = data["AreaId"];
            this.areaName = data["AreaName"];
            this.valueStreamId = data["ValueStreamId"];
            this.valueStreamName = data["ValueStreamName"];
            this.statusName = data["StatusName"];
            this.status = data["Status"];
        }
    }

    static fromJS(data: any): StationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new StationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UpdatedOn"] = this.updatedOn;
        data["UpdatedBy"] = this.updatedBy;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["PlantId"] = this.plantId;
        data["PlantName"] = this.plantName;
        data["LineId"] = this.lineId;
        data["LineName"] = this.lineName;
        data["AreaId"] = this.areaId;
        data["AreaName"] = this.areaName;
        data["ValueStreamId"] = this.valueStreamId;
        data["ValueStreamName"] = this.valueStreamName;
        data["StatusName"] = this.statusName;
        data["Status"] = this.status;
        return data; 
    }
}

export interface IStationDetailDto {
    id: string | undefined;
    updatedOn: string | undefined;
    updatedBy: string | undefined;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    plantId: string | undefined;
    plantName: string | undefined;
    lineId: string | undefined;
    lineName: string | undefined;
    areaId: string | undefined;
    areaName: string | undefined;
    valueStreamId: string | undefined;
    valueStreamName: string | undefined;
    statusName: string | undefined;
    status: string | undefined;
}

export class MenuEntity implements IMenuEntity {
    id!: number | undefined;
    title!: string | undefined;
    url!: string | undefined;
    icon!: string | undefined;
    unlinked!: boolean | undefined;
    position!: number | undefined;
    items!: MenuEntity[] | undefined;
    chineseTitle!: string | undefined;

    constructor(data?: IMenuEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.url = data["url"];
            this.icon = data["icon"];
            this.unlinked = data["unlinked"];
            this.position = data["position"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MenuEntity.fromJS(item));
            }
            this.chineseTitle = data["chineseTitle"];
        }
    }

    static fromJS(data: any): MenuEntity {
        data = typeof data === 'object' ? data : {};
        let result = new MenuEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["unlinked"] = this.unlinked;
        data["position"] = this.position;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["chineseTitle"] = this.chineseTitle;
        return data; 
    }
}

export interface IMenuEntity {
    id: number | undefined;
    title: string | undefined;
    url: string | undefined;
    icon: string | undefined;
    unlinked: boolean | undefined;
    position: number | undefined;
    items: MenuEntity[] | undefined;
    chineseTitle: string | undefined;
}

export class LineOutput implements ILineOutput {
    /** ID */
    id!: string | undefined;
    /** 产线编号 */
    code!: string | undefined;
    /** 产线名称 */
    name!: string | undefined;

    constructor(data?: ILineOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): LineOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LineOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        return data; 
    }
}

export interface ILineOutput {
    /** ID */
    id: string | undefined;
    /** 产线编号 */
    code: string | undefined;
    /** 产线名称 */
    name: string | undefined;
}

export class DeviceOutput implements IDeviceOutput {
    /** ID */
    id!: string | undefined;
    /** 设备名称 */
    deviceName!: string | undefined;

    constructor(data?: IDeviceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.deviceName = data["DeviceName"];
        }
    }

    static fromJS(data: any): DeviceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DeviceName"] = this.deviceName;
        return data; 
    }
}

export interface IDeviceOutput {
    /** ID */
    id: string | undefined;
    /** 设备名称 */
    deviceName: string | undefined;
}

export class CodeConfigOutput implements ICodeConfigOutput {
    code!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICodeConfigOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["Code"];
            this.description = data["Description"];
        }
    }

    static fromJS(data: any): CodeConfigOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CodeConfigOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Description"] = this.description;
        return data; 
    }
}

export interface ICodeConfigOutput {
    code: string | undefined;
    description: string | undefined;
}

export class TpmPlanDetailQueryDto implements ITpmPlanDetailQueryDto {
    area!: string | undefined;
    valueStream!: string | undefined;
    line!: string | undefined;
    device!: string | undefined;
    planDate!: Date | undefined;
    status!: string | undefined;
    /** 分页，当前页数 */
    pageIndex!: number | undefined;
    /** 分页，当前每页多少条数据 */
    pageSize!: number | undefined;

    constructor(data?: ITpmPlanDetailQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.area = data["Area"];
            this.valueStream = data["ValueStream"];
            this.line = data["Line"];
            this.device = data["Device"];
            this.planDate = data["PlanDate"] ? new Date(data["PlanDate"].toString()) : <any>undefined;
            this.status = data["Status"];
            this.pageIndex = data["PageIndex"];
            this.pageSize = data["PageSize"];
        }
    }

    static fromJS(data: any): TpmPlanDetailQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanDetailQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Area"] = this.area;
        data["ValueStream"] = this.valueStream;
        data["Line"] = this.line;
        data["Device"] = this.device;
        data["PlanDate"] = this.planDate ? this.planDate.toISOString() : <any>undefined;
        data["Status"] = this.status;
        data["PageIndex"] = this.pageIndex;
        data["PageSize"] = this.pageSize;
        return data; 
    }
}

export interface ITpmPlanDetailQueryDto {
    area: string | undefined;
    valueStream: string | undefined;
    line: string | undefined;
    device: string | undefined;
    planDate: Date | undefined;
    status: string | undefined;
    /** 分页，当前页数 */
    pageIndex: number | undefined;
    /** 分页，当前每页多少条数据 */
    pageSize: number | undefined;
}

export class TpmPlanDetailDtoOutPut implements ITpmPlanDetailDtoOutPut {
    dtos!: TpmPlanDetailDto[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: ITpmPlanDetailDtoOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Dtos"] && data["Dtos"].constructor === Array) {
                this.dtos = [] as any;
                for (let item of data["Dtos"])
                    this.dtos!.push(TpmPlanDetailDto.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): TpmPlanDetailDtoOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanDetailDtoOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dtos && this.dtos.constructor === Array) {
            data["Dtos"] = [];
            for (let item of this.dtos)
                data["Dtos"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface ITpmPlanDetailDtoOutPut {
    dtos: TpmPlanDetailDto[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class TpmPlanDetailDto implements ITpmPlanDetailDto {
    id!: string | undefined;
    area!: string | undefined;
    valueStream!: string | undefined;
    line!: string | undefined;
    device!: string | undefined;
    doBy!: string | undefined;
    status!: string | undefined;
    cnDescription!: string | undefined;
    enDescription!: string | undefined;
    howToMaintain!: string | undefined;
    tools!: string | undefined;
    interval!: string | undefined;
    planDate!: string | undefined;
    needCheckValue!: boolean | undefined;
    costTime!: number | undefined;
    checkDetailId!: string | undefined;
    deviceId!: string | undefined;
    lineId!: string | undefined;

    constructor(data?: ITpmPlanDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.area = data["Area"];
            this.valueStream = data["ValueStream"];
            this.line = data["Line"];
            this.device = data["Device"];
            this.doBy = data["DoBy"];
            this.status = data["Status"];
            this.cnDescription = data["CnDescription"];
            this.enDescription = data["EnDescription"];
            this.howToMaintain = data["HowToMaintain"];
            this.tools = data["Tools"];
            this.interval = data["Interval"];
            this.planDate = data["PlanDate"];
            this.needCheckValue = data["NeedCheckValue"];
            this.costTime = data["CostTime"];
            this.checkDetailId = data["CheckDetailId"];
            this.deviceId = data["DeviceId"];
            this.lineId = data["LineId"];
        }
    }

    static fromJS(data: any): TpmPlanDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Area"] = this.area;
        data["ValueStream"] = this.valueStream;
        data["Line"] = this.line;
        data["Device"] = this.device;
        data["DoBy"] = this.doBy;
        data["Status"] = this.status;
        data["CnDescription"] = this.cnDescription;
        data["EnDescription"] = this.enDescription;
        data["HowToMaintain"] = this.howToMaintain;
        data["Tools"] = this.tools;
        data["Interval"] = this.interval;
        data["PlanDate"] = this.planDate;
        data["NeedCheckValue"] = this.needCheckValue;
        data["CostTime"] = this.costTime;
        data["CheckDetailId"] = this.checkDetailId;
        data["DeviceId"] = this.deviceId;
        data["LineId"] = this.lineId;
        return data; 
    }
}

export interface ITpmPlanDetailDto {
    id: string | undefined;
    area: string | undefined;
    valueStream: string | undefined;
    line: string | undefined;
    device: string | undefined;
    doBy: string | undefined;
    status: string | undefined;
    cnDescription: string | undefined;
    enDescription: string | undefined;
    howToMaintain: string | undefined;
    tools: string | undefined;
    interval: string | undefined;
    planDate: string | undefined;
    needCheckValue: boolean | undefined;
    costTime: number | undefined;
    checkDetailId: string | undefined;
    deviceId: string | undefined;
    lineId: string | undefined;
}

export class CheckDetailDto implements ICheckDetailDto {
    id!: string | undefined;
    tPMPlanDetailId!: string | undefined;
    status!: string | undefined;
    statusValue!: number | undefined;
    checkValue!: string | undefined;
    planDate!: string | undefined;
    isExpired!: boolean | undefined;
    actualDate!: string | undefined;
    doUser!: string | undefined;
    doUserName!: string | undefined;
    checkUser!: string | undefined;
    checkUserName!: string | undefined;
    canDoSave!: boolean | undefined;
    canDoComplete!: boolean | undefined;
    attachments!: AttachmentDto[] | undefined;
    opls!: OplDto[] | undefined;
    repairLogs!: RepairLogDto[] | undefined;
    amendmentLogs!: AmendmentLogDto[] | undefined;
    cnDescription!: string | undefined;
    enDescription!: string | undefined;
    howToMaintain!: string | undefined;
    tools!: string | undefined;
    interval!: string | undefined;
    needCheckValue!: boolean | undefined;
    costTime!: number | undefined;
    deviceId!: string | undefined;
    lineId!: string | undefined;
    rowNo!: number | undefined;
    isNg!: boolean | undefined;

    constructor(data?: ICheckDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.tPMPlanDetailId = data["TPMPlanDetailId"];
            this.status = data["Status"];
            this.statusValue = data["StatusValue"];
            this.checkValue = data["CheckValue"];
            this.planDate = data["PlanDate"];
            this.isExpired = data["IsExpired"];
            this.actualDate = data["ActualDate"];
            this.doUser = data["DoUser"];
            this.doUserName = data["DoUserName"];
            this.checkUser = data["CheckUser"];
            this.checkUserName = data["CheckUserName"];
            this.canDoSave = data["CanDoSave"];
            this.canDoComplete = data["CanDoComplete"];
            if (data["Attachments"] && data["Attachments"].constructor === Array) {
                this.attachments = [] as any;
                for (let item of data["Attachments"])
                    this.attachments!.push(AttachmentDto.fromJS(item));
            }
            if (data["Opls"] && data["Opls"].constructor === Array) {
                this.opls = [] as any;
                for (let item of data["Opls"])
                    this.opls!.push(OplDto.fromJS(item));
            }
            if (data["RepairLogs"] && data["RepairLogs"].constructor === Array) {
                this.repairLogs = [] as any;
                for (let item of data["RepairLogs"])
                    this.repairLogs!.push(RepairLogDto.fromJS(item));
            }
            if (data["AmendmentLogs"] && data["AmendmentLogs"].constructor === Array) {
                this.amendmentLogs = [] as any;
                for (let item of data["AmendmentLogs"])
                    this.amendmentLogs!.push(AmendmentLogDto.fromJS(item));
            }
            this.cnDescription = data["CnDescription"];
            this.enDescription = data["EnDescription"];
            this.howToMaintain = data["HowToMaintain"];
            this.tools = data["Tools"];
            this.interval = data["Interval"];
            this.needCheckValue = data["NeedCheckValue"];
            this.costTime = data["CostTime"];
            this.deviceId = data["DeviceId"];
            this.lineId = data["LineId"];
            this.rowNo = data["RowNo"];
        }
    }

    static fromJS(data: any): CheckDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TPMPlanDetailId"] = this.tPMPlanDetailId;
        data["Status"] = this.status;
        data["StatusValue"] = this.statusValue;
        data["CheckValue"] = this.checkValue;
        data["PlanDate"] = this.planDate;
        data["IsExpired"] = this.isExpired;
        data["ActualDate"] = this.actualDate;
        data["DoUser"] = this.doUser;
        data["DoUserName"] = this.doUserName;
        data["CheckUser"] = this.checkUser;
        data["CheckUserName"] = this.checkUserName;
        data["CanDoSave"] = this.canDoSave;
        data["CanDoComplete"] = this.canDoComplete;
        if (this.attachments && this.attachments.constructor === Array) {
            data["Attachments"] = [];
            for (let item of this.attachments)
                data["Attachments"].push(item.toJSON());
        }
        if (this.opls && this.opls.constructor === Array) {
            data["Opls"] = [];
            for (let item of this.opls)
                data["Opls"].push(item.toJSON());
        }
        if (this.repairLogs && this.repairLogs.constructor === Array) {
            data["RepairLogs"] = [];
            for (let item of this.repairLogs)
                data["RepairLogs"].push(item.toJSON());
        }
        if (this.amendmentLogs && this.amendmentLogs.constructor === Array) {
            data["AmendmentLogs"] = [];
            for (let item of this.amendmentLogs)
                data["AmendmentLogs"].push(item.toJSON());
        }
        data["CnDescription"] = this.cnDescription;
        data["EnDescription"] = this.enDescription;
        data["HowToMaintain"] = this.howToMaintain;
        data["Tools"] = this.tools;
        data["Interval"] = this.interval;
        data["NeedCheckValue"] = this.needCheckValue;
        data["CostTime"] = this.costTime;
        data["DeviceId"] = this.deviceId;
        data["LineId"] = this.lineId;
        data["RowNo"] = this.rowNo;
        return data; 
    }
}

export interface ICheckDetailDto {
    id: string | undefined;
    tPMPlanDetailId: string | undefined;
    status: string | undefined;
    statusValue: number | undefined;
    checkValue: string | undefined;
    planDate: string | undefined;
    isExpired: boolean | undefined;
    actualDate: string | undefined;
    doUser: string | undefined;
    doUserName: string | undefined;
    checkUser: string | undefined;
    checkUserName: string | undefined;
    canDoSave: boolean | undefined;
    canDoComplete: boolean | undefined;
    attachments: AttachmentDto[] | undefined;
    opls: OplDto[] | undefined;
    repairLogs: RepairLogDto[] | undefined;
    amendmentLogs: AmendmentLogDto[] | undefined;
    cnDescription: string | undefined;
    enDescription: string | undefined;
    howToMaintain: string | undefined;
    tools: string | undefined;
    interval: string | undefined;
    needCheckValue: boolean | undefined;
    costTime: number | undefined;
    deviceId: string | undefined;
    lineId: string | undefined;
    rowNo: number | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    id!: string | undefined;
    name!: string | undefined;
    downloadUri!: string | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.downloadUri = data["DownloadUri"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["DownloadUri"] = this.downloadUri;
        return data; 
    }
}

export interface IAttachmentDto {
    id: string | undefined;
    name: string | undefined;
    downloadUri: string | undefined;
}

export class RepairLogDto implements IRepairLogDto {
    id!: string | undefined;
    action!: string | undefined;
    description!: string | undefined;
    createTime!: string | undefined;
    createdBy!: string | undefined;
    checkDetailId!: string | undefined;
    writeLog!: boolean | undefined;

    constructor(data?: IRepairLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.action = data["Action"];
            this.description = data["Description"];
            this.createTime = data["CreateTime"];
            this.createdBy = data["CreatedBy"];
            this.checkDetailId = data["CheckDetailId"];
            this.writeLog = data["WriteLog"];
        }
    }

    static fromJS(data: any): RepairLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepairLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Action"] = this.action;
        data["Description"] = this.description;
        data["CreateTime"] = this.createTime;
        data["CreatedBy"] = this.createdBy;
        data["CheckDetailId"] = this.checkDetailId;
        data["WriteLog"] = this.writeLog;
        return data; 
    }
}

export interface IRepairLogDto {
    id: string | undefined;
    action: string | undefined;
    description: string | undefined;
    createTime: string | undefined;
    createdBy: string | undefined;
    checkDetailId: string | undefined;
    writeLog: boolean | undefined;
}

export class AmendmentLogDto implements IAmendmentLogDto {
    id!: string | undefined;
    description!: string | undefined;
    createTime!: string | undefined;
    createdBy!: string | undefined;
    checkDetailId!: string | undefined;

    constructor(data?: IAmendmentLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.description = data["Description"];
            this.createTime = data["CreateTime"];
            this.createdBy = data["CreatedBy"];
            this.checkDetailId = data["CheckDetailId"];
        }
    }

    static fromJS(data: any): AmendmentLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AmendmentLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Description"] = this.description;
        data["CreateTime"] = this.createTime;
        data["CreatedBy"] = this.createdBy;
        data["CheckDetailId"] = this.checkDetailId;
        return data; 
    }
}

export interface IAmendmentLogDto {
    id: string | undefined;
    description: string | undefined;
    createTime: string | undefined;
    createdBy: string | undefined;
    checkDetailId: string | undefined;
}

export class DoBySaveCheckListDto implements IDoBySaveCheckListDto {
    id!: string | undefined;
    rowNo!: number | undefined;
    checkDetailId!: string | undefined;
    checkValue!: string | undefined;
    doUserEmployeeNo!: string | undefined;
    doUserName!: string | undefined;
    checkUserEmployeeNo!: string | undefined;
    checkUserName!: string | undefined;
    lineId!: string | undefined;
    deviceId!: string | undefined;
    tPMPlanDetailId!: string | undefined;
    writeLog!: boolean | undefined;

    constructor(data?: IDoBySaveCheckListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.rowNo = data["RowNo"];
            this.checkDetailId = data["CheckDetailId"];
            this.checkValue = data["CheckValue"];
            this.doUserEmployeeNo = data["DoUserEmployeeNo"];
            this.doUserName = data["DoUserName"];
            this.checkUserEmployeeNo = data["CheckUserEmployeeNo"];
            this.checkUserName = data["CheckUserName"];
            this.lineId = data["LineId"];
            this.deviceId = data["DeviceId"];
            this.tPMPlanDetailId = data["TPMPlanDetailId"];
            this.writeLog = data["WriteLog"];
        }
    }

    static fromJS(data: any): DoBySaveCheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoBySaveCheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["RowNo"] = this.rowNo;
        data["CheckDetailId"] = this.checkDetailId;
        data["CheckValue"] = this.checkValue;
        data["DoUserEmployeeNo"] = this.doUserEmployeeNo;
        data["DoUserName"] = this.doUserName;
        data["CheckUserEmployeeNo"] = this.checkUserEmployeeNo;
        data["CheckUserName"] = this.checkUserName;
        data["LineId"] = this.lineId;
        data["DeviceId"] = this.deviceId;
        data["TPMPlanDetailId"] = this.tPMPlanDetailId;
        data["WriteLog"] = this.writeLog;
        return data; 
    }
}

export interface IDoBySaveCheckListDto {
    id: string | undefined;
    rowNo: number | undefined;
    checkDetailId: string | undefined;
    checkValue: string | undefined;
    doUserEmployeeNo: string | undefined;
    doUserName: string | undefined;
    checkUserEmployeeNo: string | undefined;
    checkUserName: string | undefined;
    lineId: string | undefined;
    deviceId: string | undefined;
    tPMPlanDetailId: string | undefined;
    writeLog: boolean | undefined;
}

export class MarkCheckDetailCompleteDto implements IMarkCheckDetailCompleteDto {
    checkDetailId!: string | undefined;
    checkUserEmployeeNo!: string | undefined;
    checkUserName!: string | undefined;
    writeLog!: boolean | undefined;

    constructor(data?: IMarkCheckDetailCompleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkDetailId = data["CheckDetailId"];
            this.checkUserEmployeeNo = data["CheckUserEmployeeNo"];
            this.checkUserName = data["CheckUserName"];
            this.writeLog = data["WriteLog"];
        }
    }

    static fromJS(data: any): MarkCheckDetailCompleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new MarkCheckDetailCompleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CheckDetailId"] = this.checkDetailId;
        data["CheckUserEmployeeNo"] = this.checkUserEmployeeNo;
        data["CheckUserName"] = this.checkUserName;
        data["WriteLog"] = this.writeLog;
        return data; 
    }
}

export interface IMarkCheckDetailCompleteDto {
    checkDetailId: string | undefined;
    checkUserEmployeeNo: string | undefined;
    checkUserName: string | undefined;
    writeLog: boolean | undefined;
}

export class ChangeTpmPlanDateDto implements IChangeTpmPlanDateDto {
    checkDetailId!: string | undefined;
    planDate!: Date | undefined;

    constructor(data?: IChangeTpmPlanDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkDetailId = data["CheckDetailId"];
            this.planDate = data["PlanDate"] ? new Date(data["PlanDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangeTpmPlanDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeTpmPlanDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CheckDetailId"] = this.checkDetailId;
        data["PlanDate"] = this.planDate ? this.planDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IChangeTpmPlanDateDto {
    checkDetailId: string | undefined;
    planDate: Date | undefined;
}

/** calendar数据， 备注：字段千万不可改成大写，否则deveextreme不识别，坑 */
export class TpmCalendarOutput implements ITpmCalendarOutput {
    /** 主键 */
    id!: string | undefined;
    /** 时间标题 */
    text!: string | undefined;
    /** 事件开始时间 */
    startDate!: Date | undefined;
    /** 事件结束时间 */
    endDate!: Date | undefined;
    /** 是否是全天事件 */
    allDay!: boolean | undefined;
    /** 是否完成 */
    isDone!: boolean | undefined;
    /** 颜色，事件的背景颜色 */
    color!: string | undefined;

    constructor(data?: ITpmCalendarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.isDone = data["isDone"];
            this.color = data["color"];
        }
    }

    static fromJS(data: any): TpmCalendarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TpmCalendarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["isDone"] = this.isDone;
        data["color"] = this.color;
        return data; 
    }
}

/** calendar数据， 备注：字段千万不可改成大写，否则deveextreme不识别，坑 */
export interface ITpmCalendarOutput {
    /** 主键 */
    id: string | undefined;
    /** 时间标题 */
    text: string | undefined;
    /** 事件开始时间 */
    startDate: Date | undefined;
    /** 事件结束时间 */
    endDate: Date | undefined;
    /** 是否是全天事件 */
    allDay: boolean | undefined;
    /** 是否完成 */
    isDone: boolean | undefined;
    /** 颜色，事件的背景颜色 */
    color: string | undefined;
}

export class TpmCalendarDetail implements ITpmCalendarDetail {
    /** 主键 */
    id!: string | undefined;
    /** 维修项名称 */
    text!: string | undefined;
    /** 开始时间 */
    startDate!: Date | undefined;
    /** 结束时间 */
    endDate!: Date | undefined;
    /** 是否是整天事件 */
    allDay!: boolean | undefined;
    /** 描述（修改原因） */
    description!: string | undefined;
    /** 操作人工号 */
    no!: string | undefined;
    /** 操作人姓名 */
    name!: string | undefined;

    constructor(data?: ITpmCalendarDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.text = data["Text"];
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>undefined;
            this.allDay = data["AllDay"];
            this.description = data["Description"];
            this.no = data["No"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): TpmCalendarDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TpmCalendarDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Text"] = this.text;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["AllDay"] = this.allDay;
        data["Description"] = this.description;
        data["No"] = this.no;
        data["Name"] = this.name;
        return data; 
    }
}

export interface ITpmCalendarDetail {
    /** 主键 */
    id: string | undefined;
    /** 维修项名称 */
    text: string | undefined;
    /** 开始时间 */
    startDate: Date | undefined;
    /** 结束时间 */
    endDate: Date | undefined;
    /** 是否是整天事件 */
    allDay: boolean | undefined;
    /** 描述（修改原因） */
    description: string | undefined;
    /** 操作人工号 */
    no: string | undefined;
    /** 操作人姓名 */
    name: string | undefined;
}

export class TpmPlanOutput implements ITpmPlanOutput {
    models!: TpmPlanOutputModel[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: ITpmPlanOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Models"] && data["Models"].constructor === Array) {
                this.models = [] as any;
                for (let item of data["Models"])
                    this.models!.push(TpmPlanOutputModel.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): TpmPlanOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.models && this.models.constructor === Array) {
            data["Models"] = [];
            for (let item of this.models)
                data["Models"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface ITpmPlanOutput {
    models: TpmPlanOutputModel[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class TpmPlanOutputModel implements ITpmPlanOutputModel {
    id!: string | undefined;
    version!: string | undefined;
    area!: string | undefined;
    valueStream!: string | undefined;
    line!: string | undefined;
    deviceName!: string | undefined;
    status!: string | undefined;
    issueDate!: Date | undefined;
    lastUpdatedTime!: Date | undefined;

    constructor(data?: ITpmPlanOutputModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.version = data["Version"];
            this.area = data["Area"];
            this.valueStream = data["ValueStream"];
            this.line = data["Line"];
            this.deviceName = data["DeviceName"];
            this.status = data["Status"];
            this.issueDate = data["IssueDate"] ? new Date(data["IssueDate"].toString()) : <any>undefined;
            this.lastUpdatedTime = data["LastUpdatedTime"] ? new Date(data["LastUpdatedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TpmPlanOutputModel {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanOutputModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Version"] = this.version;
        data["Area"] = this.area;
        data["ValueStream"] = this.valueStream;
        data["Line"] = this.line;
        data["DeviceName"] = this.deviceName;
        data["Status"] = this.status;
        data["IssueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["LastUpdatedTime"] = this.lastUpdatedTime ? this.lastUpdatedTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITpmPlanOutputModel {
    id: string | undefined;
    version: string | undefined;
    area: string | undefined;
    valueStream: string | undefined;
    line: string | undefined;
    deviceName: string | undefined;
    status: string | undefined;
    issueDate: Date | undefined;
    lastUpdatedTime: Date | undefined;
}

export class TpmPlanHistoryOutput implements ITpmPlanHistoryOutput {
    action!: string | undefined;
    actionTime!: Date | undefined;
    doBy!: string | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: ITpmPlanHistoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["Action"];
            this.actionTime = data["ActionTime"] ? new Date(data["ActionTime"].toString()) : <any>undefined;
            this.doBy = data["DoBy"];
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): TpmPlanHistoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanHistoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Action"] = this.action;
        data["ActionTime"] = this.actionTime ? this.actionTime.toISOString() : <any>undefined;
        data["DoBy"] = this.doBy;
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface ITpmPlanHistoryOutput {
    action: string | undefined;
    actionTime: Date | undefined;
    doBy: string | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class ValidationResultModel implements IValidationResultModel {
    code!: string | undefined;
    content!: string | undefined;
    parameters!: any[] | undefined;

    constructor(data?: IValidationResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["Code"];
            this.content = data["Content"];
            if (data["Parameters"] && data["Parameters"].constructor === Array) {
                this.parameters = [] as any;
                for (let item of data["Parameters"])
                    this.parameters!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Content"] = this.content;
        if (this.parameters && this.parameters.constructor === Array) {
            data["Parameters"] = [];
            for (let item of this.parameters)
                data["Parameters"].push(item);
        }
        return data; 
    }
}

export interface IValidationResultModel {
    code: string | undefined;
    content: string | undefined;
    parameters: any[] | undefined;
}

export class TpmPlanDetailOutput implements ITpmPlanDetailOutput {
    models!: TpmPlanDetailOutputModel[] | undefined;
    /** 总数量 */
    totalCount!: number | undefined;

    constructor(data?: ITpmPlanDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Models"] && data["Models"].constructor === Array) {
                this.models = [] as any;
                for (let item of data["Models"])
                    this.models!.push(TpmPlanDetailOutputModel.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): TpmPlanDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.models && this.models.constructor === Array) {
            data["Models"] = [];
            for (let item of this.models)
                data["Models"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        return data; 
    }
}

export interface ITpmPlanDetailOutput {
    models: TpmPlanDetailOutputModel[] | undefined;
    /** 总数量 */
    totalCount: number | undefined;
}

export class TpmPlanDetailOutputModel implements ITpmPlanDetailOutputModel {
    id!: string | undefined;
    cnDescription!: string | undefined;
    enDescription!: string | undefined;
    description!: string | undefined;
    howToMaintain!: string | undefined;
    nextTime!: Date | undefined;
    cost!: number | undefined;
    tools!: string | undefined;
    interval!: string | undefined;
    intervalCode!: number | undefined;
    doBy!: string | undefined;
    checkBy!: string | undefined;
    tPMPlanId!: string | undefined;
    createdBy!: string | undefined;
    createdOn!: Date | undefined;
    checkValue!: boolean | undefined;
    notification!: boolean | undefined;
    notificationPerson!: string | undefined;
    maintType!: string | undefined;

    constructor(data?: ITpmPlanDetailOutputModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.cnDescription = data["CnDescription"];
            this.enDescription = data["EnDescription"];
            this.description = data["Description"];
            this.howToMaintain = data["HowToMaintain"];
            this.nextTime = data["NextTime"] ? new Date(data["NextTime"].toString()) : <any>undefined;
            this.cost = data["Cost"];
            this.tools = data["Tools"];
            this.interval = data["Interval"];
            this.intervalCode = data["IntervalCode"];
            this.doBy = data["DoBy"];
            this.checkBy = data["CheckBy"];
            this.tPMPlanId = data["TPMPlanId"];
            this.createdBy = data["CreatedBy"];
            this.createdOn = data["CreatedOn"] ? new Date(data["CreatedOn"].toString()) : <any>undefined;
            this.checkValue = data["CheckValue"];
            this.notification = data["Notification"];
            this.notificationPerson = data["NotificationPerson"];
            this.maintType = data["MaintType"];
        }
    }

    static fromJS(data: any): TpmPlanDetailOutputModel {
        data = typeof data === 'object' ? data : {};
        let result = new TpmPlanDetailOutputModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CnDescription"] = this.cnDescription;
        data["EnDescription"] = this.enDescription;
        data["Description"] = this.description;
        data["HowToMaintain"] = this.howToMaintain;
        data["NextTime"] = this.nextTime ? this.nextTime.toISOString() : <any>undefined;
        data["Cost"] = this.cost;
        data["Tools"] = this.tools;
        data["Interval"] = this.interval;
        data["IntervalCode"] = this.intervalCode;
        data["DoBy"] = this.doBy;
        data["CheckBy"] = this.checkBy;
        data["TPMPlanId"] = this.tPMPlanId;
        data["CreatedBy"] = this.createdBy;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CheckValue"] = this.checkValue;
        data["Notification"] = this.notification;
        data["NotificationPerson"] = this.notificationPerson;
        data["MaintType"] = this.maintType;
        return data; 
    }
}

export interface ITpmPlanDetailOutputModel {
    id: string | undefined;
    cnDescription: string | undefined;
    enDescription: string | undefined;
    description: string | undefined;
    howToMaintain: string | undefined;
    nextTime: Date | undefined;
    cost: number | undefined;
    tools: string | undefined;
    interval: string | undefined;
    intervalCode: number | undefined;
    doBy: string | undefined;
    checkBy: string | undefined;
    tPMPlanId: string | undefined;
    createdBy: string | undefined;
    createdOn: Date | undefined;
    checkValue: boolean | undefined;
    notification: boolean | undefined;
    notificationPerson: string | undefined;
    maintType: string | undefined;
}

export class IFormFile implements IIFormFile {
    contentType!: string | undefined;
    contentDisposition!: string | undefined;
    headers!: { [key: string] : string[]; } | undefined;
    length!: number | undefined;
    name!: string | undefined;
    fileName!: string | undefined;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["ContentType"];
            this.contentDisposition = data["ContentDisposition"];
            if (data["Headers"]) {
                this.headers = {} as any;
                for (let key in data["Headers"]) {
                    if (data["Headers"].hasOwnProperty(key))
                        this.headers![key] = data["Headers"][key] !== undefined ? data["Headers"][key] : [];
                }
            }
            this.length = data["Length"];
            this.name = data["Name"];
            this.fileName = data["FileName"];
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentType"] = this.contentType;
        data["ContentDisposition"] = this.contentDisposition;
        if (this.headers) {
            data["Headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["Headers"][key] = this.headers[key];
            }
        }
        data["Length"] = this.length;
        data["Name"] = this.name;
        data["FileName"] = this.fileName;
        return data; 
    }
}

export interface IIFormFile {
    contentType: string | undefined;
    contentDisposition: string | undefined;
    headers: { [key: string] : string[]; } | undefined;
    length: number | undefined;
    name: string | undefined;
    fileName: string | undefined;
}

export class ValueStreamOutput implements IValueStreamOutput {
    id!: string | undefined;
    createdOn!: Date | undefined;
    createdBy!: string | undefined;
    updatedOn!: Date | undefined;
    updatedBy!: string | undefined;
    plantId!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    isNewLine!: boolean | undefined;
    description!: string | undefined;
    plantCode!: string | undefined;
    plantName!: string | undefined;
    areaId!: string | undefined;
    areaCode!: string | undefined;
    areaName!: string | undefined;
    status!: number | undefined;
    statusName!: string | undefined;
    isDeleted!: boolean | undefined;

    constructor(data?: IValueStreamOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.createdOn = data["CreatedOn"] ? new Date(data["CreatedOn"].toString()) : <any>undefined;
            this.createdBy = data["CreatedBy"];
            this.updatedOn = data["UpdatedOn"] ? new Date(data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedBy = data["UpdatedBy"];
            this.plantId = data["PlantId"];
            this.code = data["Code"];
            this.name = data["Name"];
            this.isActive = data["IsActive"];
            this.isNewLine = data["IsNewLine"];
            this.description = data["Description"];
            this.plantCode = data["PlantCode"];
            this.plantName = data["PlantName"];
            this.areaId = data["AreaId"];
            this.areaCode = data["AreaCode"];
            this.areaName = data["AreaName"];
            this.status = data["Status"];
            this.statusName = data["StatusName"];
            this.isDeleted = data["IsDeleted"];
        }
    }

    static fromJS(data: any): ValueStreamOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ValueStreamOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedBy"] = this.createdBy;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedBy"] = this.updatedBy;
        data["PlantId"] = this.plantId;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsNewLine"] = this.isNewLine;
        data["Description"] = this.description;
        data["PlantCode"] = this.plantCode;
        data["PlantName"] = this.plantName;
        data["AreaId"] = this.areaId;
        data["AreaCode"] = this.areaCode;
        data["AreaName"] = this.areaName;
        data["Status"] = this.status;
        data["StatusName"] = this.statusName;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IValueStreamOutput {
    id: string | undefined;
    createdOn: Date | undefined;
    createdBy: string | undefined;
    updatedOn: Date | undefined;
    updatedBy: string | undefined;
    plantId: string | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    isNewLine: boolean | undefined;
    description: string | undefined;
    plantCode: string | undefined;
    plantName: string | undefined;
    areaId: string | undefined;
    areaCode: string | undefined;
    areaName: string | undefined;
    status: number | undefined;
    statusName: string | undefined;
    isDeleted: boolean | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}